{"title":"sort 算法","uid":"bd2189ae81127890cb8b79118f0d3213","slug":"sort","date":"2022-10-28T02:38:18.000Z","updated":"2022-10-30T17:01:05.146Z","comments":true,"path":"api/articles/sort.json","keywords":null,"cover":"https://soj.csgrandeur.cn/static/image/global/badge.png","content":"<h2 id=\"Swap交换函数\"><a href=\"#Swap交换函数\" class=\"headerlink\" title=\"Swap交换函数\"></a>Swap交换函数</h2><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void swap(int &amp;a,int &amp;b)\n&#123;\n\tint temp&#x3D;a;\n\ta&#x3D;b;\n\tb&#x3D;temp;\n&#125;</code></pre>\n\n<p>void swap(int &amp;a,int &amp;b) 为什么要加&amp;符号？？</p>\n<p>参数里的&amp;表示引用型参数，在一般的参数传递的时候，形参是实参的副本，也就是说形参和实参在内存中的位置不同，用了引用型参数后，形参和实参在内存中的位置是一样的。**&amp; 这里表示引用，说明需要传递变量给这个函数，函数中可以对参数的值进行修改<br>如果没有 &amp;，修改的就是函数体中的临时变量。**</p>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void bubble_sort(int* arr,int len)\n&#123;\n\tfor(int i&#x3D;0;i&lt;len-1;i++)\n\t&#123;\n\t\tfor(int k&#x3D;0;k&lt;len-1-i;k++)\n\t\t&#123;\n\t\t\tif(arr[k]&gt;arr[k+1]) &#x2F;&#x2F;表示从小到大排\n\t\t\t&#123;\n\t\t\t\tswap(arr[k],arr[k+1]);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<p>冒泡排序的时间复杂度为O（n^2）</p>\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p>insertion sort 每次从未排序中取出一个元素插入到已排序序列中，不断重复直至所有元素均被移到排序序列</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Pannta/img-store/img/20221007170523.svg\"></p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif\"></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void insertion_sort (int arr[], int len)\n&#123;\n\tint j,key;\n\tfor(int i&#x3D;1;i&lt;len;i++)\n\t&#123;\n\t\tkey&#x3D;arr[i];\n\t\tj&#x3D;i-1;\n\t\twhile(j&gt;&#x3D;0 &amp;&amp; (arr[j]&gt;key))\n\t\t&#123;\n\t\t\tarr[j+1]&#x3D;arr[j]; &#x2F;&#x2F;移位，留出插入空格\n\t\t\tj--;\n\t\t&#125;\n\t\tarr[j+1]&#x3D;key; &#x2F;&#x2F;把新元素插入到空格中，+1是因为*\n\t&#125;\n&#125;</code></pre>\n\n<ul>\n<li>while中j要大于0原因是处理临界条件，如果key比较到第一个都不比它大的话就要插在第一个前面了，第一个移到后面</li>\n<li>arr[j+1]是因为如果当j&#x3D;0时进入循环j就等于-1，然后最后赋值要把j加一才行</li>\n<li>第一层for循环是为了选择要插入的数</li>\n<li>第二层while是为了判断插入到哪里，并且移位</li>\n</ul>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>\n<p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>\n<ul>\n<li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li>\n<li>自下而上的迭代；</li>\n</ul>\n<h4 id=\"算法步骤\"><a href=\"#算法步骤\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h4><p><img src=\"https://img2018.cnblogs.com/blog/1258817/201903/1258817-20190326201207440-689679432.gif\"></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void merge(int* arr,int left ,int middle,int right)\n&#123;\n\tint i&#x3D;left;\n\tint j&#x3D;middle;\n\tint * temp&#x3D;(int *)malloc((right-left)*4);\n\tint index&#x3D;0;\n\twhile(i&lt;middle &amp;&amp; j&lt;right)\n\t\ttemp[index++]&#x3D;arr[i]&lt;arr[j]?arr[i++]:arr[j++];\n\twhile(i&lt;middle)\n\t\ttemp[index++]&#x3D;arr[i++];\n\twhile(j&lt;right)\n\t\ttemp[index++]&#x3D;arr[j++];\n\tfor(int i&#x3D;0;i&lt;index;i++)\n\t\tarr[left+i]&#x3D;temp[i];\n\tfree(temp);\n&#125;\nvoid merge_sort(int* arr,int left ,int right)\n&#123;\n\tif(right-left&lt;&#x3D;1) return;\n\tint middle&#x3D;(left+right)&gt;&gt;1; \n\tmerge_sort(arr,left,middle);\n\tmerge_sort(arr,middle,right);\n\tmerge(arr,left,middle,right);\n\t\n&#125;</code></pre>\n\n<p>递归而言，首先肯定 要给出递归结束条件(right-left&lt;&#x3D;1),，<strong>递归的结束条件一定是：原最小子问题的解！！！而这里，当递归到最后一步时候，子数组只剩一下一个元素，而这个元素本身就是有序的，所以直接return即可（在其他问题中没准需要你给出最小子问题的解）</strong></p>\n<p><strong>递归函数和普通函数本质是一致的，并无本质区别，当发生自己调用自己的时候，你完全可以认为，它调用了一个其他函数，只是这个函数好像和自己长得一模一样</strong>，俗称双胞胎。并且和普通调用一样，每个调用都会生成一个独立的栈空间，因此，mid值并不是只有一个mid,而是在每个调用体里都有一个mid只存在自己的栈空间。</p>\n<p>因此，这里说明关于递归调用的两点：</p>\n<ul>\n<li><strong>递归调用和普通函数调用并无区别，你可以把递归调用想成调用了一个和自己长得一样的其他函数；</strong></li>\n<li><strong>既然是函数调用，栈空间就是独立的，哪怕它是递归调用，也是如此；</strong></li>\n</ul>\n<h2 id=\"C-std-sort\"><a href=\"#C-std-sort\" class=\"headerlink\" title=\"C++ std::sort()\"></a>C++ std::sort()</h2><p>实际写代码时很少手撸排序算法，因为 STL 已经为我们提供了方便好用的库函数 std::sort() ，该函<br>数定义在头文件 <algorithm> 中。</p>\n<h3 id=\"食用方法\"><a href=\"#食用方法\" class=\"headerlink\" title=\"食用方法\"></a>食用方法</h3><p>该函数的基本用法为：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">std::sort(s, s+n);</code></pre>\n\n<p>其中 s 为需要排序的数组， n 为需要排序的区间长度。该函数传入的参数为两个指针，用于指定排序<br>的范围 [L, R)。<br>例如对长度为 5 的数组进行排序：<br>注意，如果数组从第 1 位开始保存数据，那么排序时也要相应的偏移 1 位：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">std::sort(s+1, s+n+1);</code></pre>\n\n<h3 id=\"自定义排序顺序\"><a href=\"#自定义排序顺序\" class=\"headerlink\" title=\"自定义排序顺序\"></a>自定义排序顺序</h3><p>sort() 函数默认情况下是按从小到大的顺序排序的，如果我们想从大到小排序或者对结构体排序，就<br>需要向 sort() 指定我们期望的排序规则</p>\n<h4 id=\"使用标准库比较函数\"><a href=\"#使用标准库比较函数\" class=\"headerlink\" title=\"使用标准库比较函数\"></a>使用标准库比较函数</h4><p>如果只是想简单地将数组从大到小排序，标准库自带的比较函数就可以满足需求。</p>\n<p>   #include <iostream>     &#x2F;&#x2F; std::cout<br>    #include <functional>   &#x2F;&#x2F; std::greater<br>    #include <algorithm>    &#x2F;&#x2F; std::sort</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int main () &#123;\n  int numbers[]&#x3D;&#123;20,40,50,10,30&#125;;\n  std::sort (numbers, numbers+5, std::greater&lt;int&gt;());\n  for (int i&#x3D;0; i&lt;5; i++)\n    std::cout &lt;&lt; numbers[i] &lt;&lt; &#39; &#39;;\n  std::cout &lt;&lt; &#39;\\n&#39;;\n  return 0;\n&#125;</code></pre>\n<h4 id=\"自定义比较函数\"><a href=\"#自定义比较函数\" class=\"headerlink\" title=\"自定义比较函数\"></a>自定义比较函数</h4><p>自定义排序顺序的一种方法是向 sort() 多传入一个比较函数作为参数。比较函数是返回值为（或可转<br>化为） bool 类型的双参函数，它定义了元素之间的严格弱序关系，当参数 1 优先于参数 2 时返回<br>true ，反之返回 false </p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include&lt;cstdlib&gt;\n#include &lt;algorithm&gt;    \nint n&#x3D;10;\nstruct node\n&#123;\n\tint price, weight, value; &#x2F;&#x2F;价格、重量、价值\n&#125;;\nbool cmp1(const node &amp;a, const node &amp;b) &#x2F;&#x2F;规则1，按价格从小到大排序\n&#123;\n\treturn a.price &lt; b.price;\n&#125;\nbool cmp2(const node &amp;a, const node &amp;b) &#x2F;&#x2F;规则2，按价值从大到小排序\n&#123;\n\treturn a.value &gt; b.value;\n&#125;\n&#x2F;&#x2F;规则3，多关键字排序\n&#x2F;&#x2F;先按价值从大到小排序\n&#x2F;&#x2F;如果价值相同则按价格从小到大排序\n&#x2F;&#x2F;如果价值、价格都相同，则按重量从小到大排序\nbool cmp3(const node &amp;a, const node &amp;b)\n&#123;\n\tif (a.value &#x3D;&#x3D; b.value &amp;&amp; a.price &#x3D;&#x3D; b.price) return a.weight &lt; b.weight;\n\tif (a.value &#x3D;&#x3D; b.value) return a.price &lt; b.price;\n\treturn a.value &gt; b.value;\n&#125;\nnode s[105];\nint main()\n&#123;\n\tstd::sort(s, s+n, cmp1); &#x2F;&#x2F;使用规则1排序\n\tstd::sort(s, s+n, cmp2); &#x2F;&#x2F;使用规则2排序\n\tstd::sort(s, s+n, cmp3);&#x2F;&#x2F;使用规则3排序\n\treturn 0;\n&#125;</code></pre>\n\n","text":"Swap交换函数void swap(int &amp;a,int &amp;b) &#123; int temp&#x3D;a; a&#x3D;b; b&#x3D;temp; &#125; void swap(int &amp;a,int &amp;b) 为什么要加&amp;符号...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"ACM新手课堂练习","slug":"ACM新手课堂练习","count":2,"path":"api/tags/ACM新手课堂练习.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Swap%E4%BA%A4%E6%8D%A2%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">Swap交换函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">冒泡排序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">插入排序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">归并排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">算法步骤</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#C-std-sort\"><span class=\"toc-text\">C++ std::sort()</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A3%9F%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">食用方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">自定义排序顺序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">使用标准库比较函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">自定义比较函数</span></a></li></ol></li></ol></li></ol>","author":{"name":"Shockley","slug":"blog-author","avatar":"https://s1.ax1x.com/2022/10/27/xhKxMQ.jpg","link":"https://www.cnblogs.com/rock3t/","description":"菜鸟一枚，会发一些记录生活和学习笔记的小文章","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"uart学习","uid":"f4b64ea2c88bb417cb737aa4fba9997c","slug":"uart学习","date":"2022-10-28T07:49:26.000Z","updated":"2022-11-14T05:28:26.261Z","comments":true,"path":"api/articles/uart学习.json","keywords":null,"cover":"https://rm-static.djicdn.com/robomasters/dps/0e5aa183673ec1058912fc5caed4d82b.jpg","text":"串口简介（Universal Synchronous&#x2F;Asynchronous Receiver&#x2F;Transmitter） 通用异步收发传输器（没有时钟线），相对地，有时钟线就是同步通信 具有TX和RX两根线 可以将数据串行地发送给对方 串口数据按照位依次发送...","link":"","photos":[],"count_time":{"symbolsCount":"6.7k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"嵌入式学习","slug":"嵌入式学习","count":2,"path":"api/tags/嵌入式学习.json"}],"author":{"name":"Shockley","slug":"blog-author","avatar":"https://s1.ax1x.com/2022/10/27/xhKxMQ.jpg","link":"https://www.cnblogs.com/rock3t/","description":"菜鸟一枚，会发一些记录生活和学习笔记的小文章","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"python 类学习笔记","uid":"ba06baf3033674352e99290bfc5eedc6","slug":"Python类","date":"2022-10-27T13:17:47.000Z","updated":"2022-10-27T13:24:02.036Z","comments":true,"path":"api/articles/Python类.json","keywords":null,"cover":"https://ts1.cn.mm.bing.net/th/id/R-C.8ec0de2007df3ae34076936f0ecda0e1?rik=MsJLOJxegKdRzg&riu=http%3a%2f%2fpic.kekenet.com%2f2018%2f0107%2f8121515325256.jpg&ehk=spFqSEhctd04Aet1fqfDMliq48FdnXhtkJfUW9W3uoQ%3d&risl=&pid=ImgRaw&r=0&sres=1&sresct=1","text":"_ _init _ _创建classclass Dog: def __init__(self,name,breed,age): self.name&#x3D;name self.breed&#x3D;breed self.age&#x3D;age a_dog&#x3D;Dog(&...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[],"tags":[],"author":{"name":"Shockley","slug":"blog-author","avatar":"https://s1.ax1x.com/2022/10/27/xhKxMQ.jpg","link":"https://www.cnblogs.com/rock3t/","description":"菜鸟一枚，会发一些记录生活和学习笔记的小文章","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}