{"title":"FreeRTOS_队列管理","uid":"99298ce049ccdc06bc2b056b9a20c2b4","slug":"FreeRTOS-队列管理","date":"2022-11-04T13:37:18.000Z","updated":"2022-11-04T14:26:14.393Z","comments":true,"path":"api/articles/FreeRTOS-队列管理.json","keywords":null,"cover":"https://picx1.zhimg.com/v2-cacaa3d560e91f8431bb662924b3d3b1_1440w.jpg?source=172ae18b","content":"<h1 id=\"FreeRTOS队列管理\"><a href=\"#FreeRTOS队列管理\" class=\"headerlink\" title=\"FreeRTOS队列管理\"></a>FreeRTOS队列管理</h1><h2 id=\"全局变量和弊端\"><a href=\"#全局变量和弊端\" class=\"headerlink\" title=\"全局变量和弊端\"></a>全局变量和弊端</h2><p>在以往的教程中，我们创建的任务都是相对独立的，任务之间并没有互相通讯交换数据。有童鞋说当然可以通过定义一个<strong>全局变量</strong>来实现多任务之间共享数据呀。你有没有想过，如果有多个任务同时要对一个占多字节的全局变量进行修改，如果没有保护机制的话，当第一个任务赋值给全局变量赋值前几个字节后，如果此时调度器切换第二个任务执行给全局变量赋值另外的几个字节，那么这个全局变量的值就变得支离破碎毫无意义了。所以说使用全局变量其实是不太线程安全的，一种解决这个问题的方案就是采用队列。</p>\n<p><strong>队列提供了一种任务间或者任务和中断间的通讯机制。</strong></p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-f6d855b43bff4db397182a19d1151533_720w.webp\"></p>\n<p>a图是采用进程间共享内存的方式，b图是采用消息队列的方式。</p>\n<p><em>通过<strong>进程间共享内存</strong>的方式，进程之间能够更快地共用和交互数据；<strong>消息队列</strong>则是提供了一种更通用且稳定的交互数据的方式。</em></p>\n<h2 id=\"数据存储\"><a href=\"#数据存储\" class=\"headerlink\" title=\"数据存储\"></a>数据存储</h2><p>通常采用先进先出队列（FIFO）</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-971d3a960eb91ebea61bc38e834eb750_720w.webp\"></p>\n<p>队列有如下两种实现方式：</p>\n<ul>\n<li>*<strong>复制队列（Queue by copy）*</strong> 表示写入队列的数据每个字节都被完整复制到队列中了，也叫值传递</li>\n<li>*<strong>引用队列（Queue by reference）*</strong> 表示写入队列的是要写入数据的引用（或者说是一个指针指向所引用的数据）而并不是数据本身</li>\n</ul>\n<p><strong>FreeRTOS采用是复制队列的实现方式</strong></p>\n<h2 id=\"多任务访问和阻塞\"><a href=\"#多任务访问和阻塞\" class=\"headerlink\" title=\"多任务访问和阻塞\"></a>多任务访问和阻塞</h2><p>任何任务都可以往队列中发送东西</p>\n<h4 id=\"出队阻塞\"><a href=\"#出队阻塞\" class=\"headerlink\" title=\"出队阻塞\"></a>出队阻塞</h4><p>当任务尝试从一个队列中读取数据的时候，但是这个队列啊，不一定有数据，那么现在有三种选择：1.继续执行下面的程序2.等一会3，死等。选哪一个就是由阻塞时间决定的.0就是不阻塞，设置为portMAX_DELAY的话，任务就会一直进入阻塞态等待，直到收到数据为止。</p>\n<h4 id=\"入队阻塞\"><a href=\"#入队阻塞\" class=\"headerlink\" title=\"入队阻塞\"></a>入队阻塞</h4><p>任务向队列里面发消息，和出队阻塞一样，当一个任务向队列发消息的话也可以设置阻塞时间，比如任务B向队列Q发消息，队列Q是满的，情况就和上面的一样了。</p>\n<h1 id=\"常见队列操作方法\"><a href=\"#常见队列操作方法\" class=\"headerlink\" title=\"常见队列操作方法\"></a>常见队列操作方法</h1><p>下面将介绍创建和使用队列需要用到的几个函数</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize )</code></pre>\n\n<p><strong>xQueueCreate（）</strong>是创建队列用到的函数。函数的返回值是QueueHandle_t具柄类型，表示的是对所创建队列的一个引用句柄。FreeRTOS从FreeRTOS的堆中指定一些内存空间给队列使用。如果堆中没有足够空间给队列使用的话函数的返回值会是NULL。</p>\n<p><strong>这个函数本质上是一个宏，用来创建动态队列，最终会调用函数xQUEUEGenericStatic()</strong></p>\n<ul>\n<li><strong>uxQueueLength</strong> 队列包含数据的最大长度</li>\n<li><strong>uxItemSize</strong> 每个数据占用的字节大小</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">BaseType_t xQueueSend( QueueHandle_t xQueue, const void * pvItemToQueue,\nTickType_t xTicksToWait )</code></pre>\n\n<p><strong>xQueueSend（）</strong>函数用于将数据发送到队列（具体一点就是队列的尾部）。如果要在中断程序调用的话需要使用<strong>xQueueSendFromISR（）</strong>函数。</p>\n<ul>\n<li><strong>xQueue</strong> 队列的具柄，来自于<strong>xQueueCreate（）</strong>的返回值</li>\n<li><strong>pvItemToQueue</strong> 所发送数据的引用，然后这些数据会被复制到队列中</li>\n<li><strong>xTicksToWait</strong> 队列如果满时发送任务的阻塞时间（block time），上文已经介绍过，可以通过<strong>pdMS_TO_TICKS()<strong>把时间转换成节拍数。如果设置为portMAX_DELAY的话任务将永远等待下去（需要FreeRTOSConfig.h头文件中</strong>INCLUDE_vTaskSuspend</strong>参数设置为1）</li>\n<li><strong>返回值</strong> 发送数据成功时返回<strong>pdPASS</strong>，失败时返回<strong>errQUEUE_FULL</strong></li>\n</ul>\n<p>下面两个函数用于明确指定发送数据到队列的头部还是尾部。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">BaseType_t xQueueSendToFront( QueueHandle_t xQueue, const void * pvItemToQueue,\nTickType_t xTicksToWait )\nBaseType_t xQueueSendToBack( QueueHandle_t xQueue, const void * pvItemToQueue,\nTickType_t xTicksToWait )</code></pre>\n\n<p><strong>xQueueSend（）</strong>函数和<strong>xQueueSendToBack（）</strong>函数本质上是一样的。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer,\nTickType_t xTicksToWait )\n</code></pre>\n\n<ul>\n<li><strong>xQueue</strong> 队列的具柄，来自于<strong>xQueueCreate（）</strong>的返回值</li>\n<li><strong>pvBuffer</strong> 指向内存空间的一个引用，读取的数据会被复制到这片内存</li>\n<li><strong>xTicksToWait</strong> 队列如果空时接送任务的阻塞时间（block time），上文已经介绍过，可以通过<strong>pdMS_TO_TICKS()<strong>把时间转换成节拍数。如果设置为portMAX_DELAY的话任务将永远等待下去（需要FreeRTOSConfig.h头文件中</strong>INCLUDE_vTaskSuspend</strong>参数设置为1）</li>\n<li><strong>返回值</strong> 接收数据成功时返回<strong>pdPASS</strong>，失败时返回<strong>errQUEUE_EMPTY</strong></li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">UBaseType_t uxQueueMessagesWaiting( QueueHandle_t xQueue )</code></pre>\n\n<p>uxQueueMessagesWaiting（）函数用于获得队列中数据的数量</p>\n<h2 id=\"队列结构体\"><a href=\"#队列结构体\" class=\"headerlink\" title=\"队列结构体\"></a>队列结构体</h2>","text":"FreeRTOS队列管理全局变量和弊端在以往的教程中，我们创建的任务都是相对独立的，任务之间并没有互相通讯交换数据。有童鞋说当然可以通过定义一个全局变量来实现多任务之间共享数据呀。你有没有想过，如果有多个任务同时要对一个占多字节的全局变量进行修改，如果没有保护机制的话，当第一个任...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"嵌入式学习","slug":"嵌入式学习","count":2,"path":"api/tags/嵌入式学习.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#FreeRTOS%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">FreeRTOS队列管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%BC%8A%E7%AB%AF\"><span class=\"toc-text\">全局变量和弊端</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">数据存储</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%AE%BF%E9%97%AE%E5%92%8C%E9%98%BB%E5%A1%9E\"><span class=\"toc-text\">多任务访问和阻塞</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%87%BA%E9%98%9F%E9%98%BB%E5%A1%9E\"><span class=\"toc-text\">出队阻塞</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%A5%E9%98%9F%E9%98%BB%E5%A1%9E\"><span class=\"toc-text\">入队阻塞</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">常见队列操作方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%E4%BD%93\"><span class=\"toc-text\">队列结构体</span></a></li></ol></li></ol>","author":{"name":"Shockley","slug":"blog-author","avatar":"https://s1.ax1x.com/2022/10/27/xhKxMQ.jpg","link":"https://www.cnblogs.com/rock3t/","description":"菜鸟一枚，会发一些记录生活和学习笔记的小文章","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"贪心","uid":"bc70f4e05aafed03ba0181aade8d3ac9","slug":"贪心","date":"2022-11-10T01:38:30.000Z","updated":"2022-12-06T03:07:42.568Z","comments":true,"path":"api/articles/贪心.json","keywords":null,"cover":[],"text":"A - 电影节 OpenJ_Bailian - 4151大学生电影节在北大举办! 这天，在北大各地放了多部电影，给定每部电影的放映时间区间，区间重叠的电影不可能同时看（端点可以重合），问李雷最多可以看多少部电影。 Input 多组数据。每组数据开头是n(n&lt;&#x3D;10...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[],"author":{"name":"Shockley","slug":"blog-author","avatar":"https://s1.ax1x.com/2022/10/27/xhKxMQ.jpg","link":"https://www.cnblogs.com/rock3t/","description":"菜鸟一枚，会发一些记录生活和学习笔记的小文章","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"排序题目","uid":"137114166de934a4dd5b894c333fbc29","slug":"排序题目","date":"2022-10-30T13:21:16.000Z","updated":"2022-10-30T17:01:20.711Z","comments":true,"path":"api/articles/排序题目.json","keywords":null,"cover":"https://soj.csgrandeur.cn/static/image/global/badge.png","text":"Description 1冒泡排序是一种常见的排序算法，本题要求用冒泡排序算法对一组正整数进行从小到大排序. 从小到大输出排序好的数，数之间用空格分开，行尾没有多余的空格. Input多组测试数据，每组数据第一行为 n 表示有n 个数。第二行为n个空格隔开的500内的正整数. 1...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"ACM新手课堂练习","slug":"ACM新手课堂练习","count":2,"path":"api/tags/ACM新手课堂练习.json"}],"author":{"name":"Shockley","slug":"blog-author","avatar":"https://s1.ax1x.com/2022/10/27/xhKxMQ.jpg","link":"https://www.cnblogs.com/rock3t/","description":"菜鸟一枚，会发一些记录生活和学习笔记的小文章","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}