{"title":"贪心","uid":"bc70f4e05aafed03ba0181aade8d3ac9","slug":"贪心","date":"2022-11-10T01:38:30.000Z","updated":"2022-12-06T03:41:57.845Z","comments":true,"path":"api/articles/贪心.json","keywords":null,"cover":[],"content":"<h3 id=\"A-电影节-OpenJ-Bailian-4151\"><a href=\"#A-电影节-OpenJ-Bailian-4151\" class=\"headerlink\" title=\"A - 电影节 OpenJ_Bailian - 4151\"></a>A - 电影节 <code>OpenJ_Bailian - 4151</code></h3><p>大学生电影节在北大举办! 这天，在北大各地放了多部电影，给定每部电影的放映时间区间，区间重叠的电影不可能同时看（端点可以重合），问李雷最多可以看多少部电影。</p>\n<p><strong>Input</strong></p>\n<p>多组数据。每组数据开头是n(n&lt;&#x3D;100)，表示共n场电影。<br>接下来n行，每行两个整数(0到1000之间)，表示一场电影的放映区间<br>n&#x3D;0则数据结束</p>\n<p><strong>Output</strong></p>\n<p>对每组数据输出最多能看几部电影</p>\n<p>按结束时间排序，维护一个“当前完成时间”<code>nt</code>，按顺序扫描，开始时间不早于<code>nt</code>的就安排上，更新<code>nt</code>为新安排的电影的结束时间。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\nconst int maxn &#x3D; 111;\nstruct Node\n&#123;\n    int s, t;\n    bool operator&lt;(const Node&amp;that)const\n    &#123;\n        return t &lt; that.t;\n    &#125;\n&#125;;\nint n;\nNode mov[maxn];\nint main()\n&#123;\n    while(scanf(&quot;%d&quot;, &amp;n) !&#x3D; EOF &amp;&amp; n)\n    &#123;\n        for(int i &#x3D; 0; i &lt; n; i ++)\n            scanf(&quot;%d%d&quot;, &amp;mov[i].s, &amp;mov[i].t);\n        std::sort(mov, mov + n);\n        int ans &#x3D; 0, nt &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; i ++)\n            if(mov[i].s &gt;&#x3D; nt) ans ++, nt &#x3D; mov[i].t;\n        printf(&quot;%d\\n&quot;, ans);\n    &#125;\n    return 0;\n&#125;</code></pre>\n\n<h3 id=\"B-数列分段-LibreOJ-10006\"><a href=\"#B-数列分段-LibreOJ-10006\" class=\"headerlink\" title=\"B - 数列分段 LibreOJ - 10006\"></a>B - 数列分段 <code>LibreOJ - 10006</code></h3><p>对于给定的一个长度为 N<em>N</em> 的<strong>正整数</strong>数列 A_i<em>A**i</em>，现要将其分成<strong>连续的</strong>若干段，并且<strong>每段和</strong>不超过 M<em>M</em>（可以等于 M<em>M</em>），问最少能将其分成多少段使得满足要求。</p>\n<p><strong>输入格式</strong></p>\n<p>第一行包含两个正整数 N,M<em>N</em>,<em>M</em>，表示了数列 A_i<em>A**i</em> 的长度与每段和的最大值；</p>\n<p>第二行包含 N<em>N</em> 个空格隔开的非负整数 A_i<em>A**i</em>。</p>\n<p><strong>输出格式</strong></p>\n<p>输出文件仅包含一个正整数，输出最少划分的段数。</p>\n<p><strong>样例</strong></p>\n<table>\n<thead>\n<tr>\n<th>Inputcopy</th>\n<th>Outputcopy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>5 6 4 2 4 5 1</code></td>\n<td><code>3</code></td>\n</tr>\n</tbody></table>\n<p>每一段尽可能填满</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\nint n, m, a;\nint main()\n&#123;\n    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) !&#x3D; EOF)\n    &#123;\n        int now &#x3D; 0, cnt &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; i ++)\n        &#123;\n            scanf(&quot;%d&quot;, &amp;a);\n            if(now + a &lt;&#x3D; m) now +&#x3D; a;\n            else cnt ++, now &#x3D; a;\n        &#125;\n        printf(&quot;%d\\n&quot;, cnt + 1);\n    &#125;\n    return 0;\n&#125;</code></pre>\n\n<h3 id=\"C-圣诞老人的礼物-Santa-Clau’s-Gifts-OpenJ-Bailian-4110\"><a href=\"#C-圣诞老人的礼物-Santa-Clau’s-Gifts-OpenJ-Bailian-4110\" class=\"headerlink\" title=\"C - 圣诞老人的礼物-Santa Clau’s Gifts OpenJ_Bailian - 4110\"></a>C - 圣诞老人的礼物-Santa Clau’s Gifts <code>OpenJ_Bailian - 4110</code></h3><p>圣诞节来临了，在城市A中圣诞老人准备分发糖果，现在有多箱不同的糖果，每箱糖果有自己的价值和重量，每箱糖果都可以拆分成任意散装组合带走。圣诞老人的驯鹿最多只能承受一定重量的糖果，请问圣诞老人最多能带走多大价值的糖果。</p>\n<p><strong>Input</strong></p>\n<p>第一行由两个部分组成，分别为糖果箱数正整数n(1 &lt;&#x3D; n &lt;&#x3D; 100)，驯鹿能承受的最大重量正整数w（0 &lt; w &lt; 10000），两个数用空格隔开。其余n行每行对应一箱糖果，由两部分组成，分别为一箱糖果的价值正整数v和重量正整数w，中间用空格隔开。</p>\n<p><strong>Output</strong></p>\n<p>输出圣诞老人能带走的糖果的最大总价值，保留1位小数。输出为一行，以换行符结束。</p>\n<p>Sample</p>\n<table>\n<thead>\n<tr>\n<th>Inputcopy</th>\n<th>Outputcopy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>4 15 100 4 412 8 266 7 591 2</code></td>\n<td><code>1193.0</code></td>\n</tr>\n</tbody></table>\n<p>优先性价比高的</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\nconst int maxn &#x3D; 111;\nstruct Node\n&#123;\n    int v, w;\n    bool operator&lt;(const Node&amp;that)const\n    &#123;\n        return v * that.w &gt; that.v * w;\n    &#125;\n&#125;;\nNode s[maxn];\nint n, w;\nint main()\n&#123;\n    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;w) !&#x3D; EOF)\n    &#123;\n        for(int i &#x3D; 0; i &lt; n; i ++)\n            scanf(&quot;%d%d&quot;, &amp;s[i].v, &amp;s[i].w);\n        std::sort(s, s + n);\n        double ans &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n &amp;&amp; w; i ++)\n        &#123;\n            if(w &gt; s[i].w) ans +&#x3D; s[i].v, w -&#x3D; s[i].w;\n            else ans +&#x3D; 1.0 * w * s[i].v &#x2F; s[i].w, w &#x3D; 0;\n        &#125;\n        printf(&quot;%.1f\\n&quot;, ans);\n    &#125;\n    return 0;\n&#125;</code></pre>\n\n<h3 id=\"D-种树-LibreOJ-10001\"><a href=\"#D-种树-LibreOJ-10001\" class=\"headerlink\" title=\"D - 种树 LibreOJ - 10001\"></a>D - 种树 <code>LibreOJ - 10001</code></h3><p>题目描述</p>\n<p>某条街被划为 n<em>n</em> 条路段，这 n<em>n</em> 条路段依次编号为 1…<em>n</em>。每个路段最多可以种一棵树。现在居民们给出了 h<em>h</em> 组建议，每组建议包含三个整数 b,e,t<em>b</em>,<em>e</em>,<em>t</em>，表示居民希望在路段 b<em>b</em> 到 e<em>e</em> 之间至少要种 t<em>t</em> 棵树。这些建议所给路段的区间可以交叉。请问：如果要满足所有居民的建议，至少要种多少棵树。</p>\n<p><strong>输入格式</strong></p>\n<p>第一行为 n<em>n</em>，表示路段数。</p>\n<p>第二行为 h<em>h</em>，表示建议数。</p>\n<p>下面 h<em>h</em> 行描述一条建议：b, e, t<em>b</em>,<em>e</em>,<em>t</em>，用一个空格分隔。</p>\n<p><strong>输出格式</strong></p>\n<p>输出只有一个数，为满足所有居民的建议，所需要种树的最少数量。</p>\n<p>样例</p>\n<table>\n<thead>\n<tr>\n<th>Inputcopy</th>\n<th>Outputcopy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>9 4 1 4 2 4 6 2 8 9 2 3 5 2</code></td>\n<td><code>5</code></td>\n</tr>\n</tbody></table>\n<p>按区间右端点（<code>e</code>）排序，每个区间优先从后往前种树，因为靠后种树才更便于被后面的区间共用。</p>\n<p>这题的数据有坑——合法数据之后会输入一些无用数据。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\nconst int maxn &#x3D; 3e5 + 10;\nconst int maxh &#x3D; 5e5 + 10;\nstruct Node\n&#123;\n    int b, e, t;\n    bool operator&lt;(const Node&amp;that)const\n    &#123;\n        return e &lt; that.e;\n    &#125;\n&#125;;\nNode s[maxh];\nbool vis[maxn];\nint n, h;\nint main()\n&#123;\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;h);\n    memset(vis, 0, sizeof(bool) * (n + 10));\n    for(int i &#x3D; 0; i &lt; h; i ++)\n        scanf(&quot;%d%d%d&quot;, &amp;s[i].b, &amp;s[i].e, &amp;s[i].t);\n    std::sort(s, s + h);\n    for(int i &#x3D; 0; i &lt; h; i ++)\n    &#123;\n        for(int j &#x3D; s[i].b; j &lt;&#x3D; s[i].e; j ++)\n            s[i].t -&#x3D; vis[j];\n        for(int j &#x3D; s[i].e; s[i].t &gt; 0; j --)\n            if(!vis[j]) vis[j] &#x3D; true, s[i].t --;\n    &#125;\n    int ans &#x3D; 0;\n    for(int i &#x3D; 0; i &lt;&#x3D; n; i ++)\n        ans +&#x3D; vis[i];\n    printf(&quot;%d\\n&quot;, ans);\n    return 0;\n&#125;</code></pre>\n\n<h3 id=\"E-电池的寿命-OpenJ-Bailian-3468\"><a href=\"#E-电池的寿命-OpenJ-Bailian-3468\" class=\"headerlink\" title=\"E - 电池的寿命 OpenJ_Bailian - 3468\"></a>E - 电池的寿命 <code>OpenJ_Bailian - 3468</code></h3><p>小S新买了一个掌上游戏机，这个游戏机由两节5号电池供电。为了保证能够长时间玩游戏，他买了很多5号电池，这些电池的生产商不同，质量也有差异，因而使用寿命也有所不同，有的能使用5个小时，有的可能就只能使用3个小时。显然如果他只有两个电池一个能用5小时一个能用3小时，那么他只能玩3个小时的游戏，有一个电池剩下的电量无法使用，但是如果他有更多的电池，就可以更加充分地利用它们，比如他有三个电池分别能用3、3、5小时，他可以先使用两节能用3个小时的电池，使用半个小时后再把其中一个换成能使用5个小时的电池，两个半小时后再把剩下的一节电池换成刚才换下的电池（那个电池还能用2.5个小时），这样总共就可以使用5.5个小时，没有一点浪费。</p>\n<p>现在已知电池的数量和电池能够使用的时间，请你找一种方案使得使用时间尽可能的长。</p>\n<p><strong>Input</strong></p>\n<p>输入包含多组数据。每组数据包括两行，第一行是一个整数<em>N</em> (2 ≤ <em>N</em> ≤ 1000)，表示电池的数目，接下来一行是<em>N</em>个正整数表示电池能使用的时间。</p>\n<p><strong>Output</strong></p>\n<p>对每组数据输出一行，表示电池能使用的时间，保留到小数点后1位。</p>\n<p><strong>Sample</strong></p>\n<table>\n<thead>\n<tr>\n<th>Inputcopy</th>\n<th>Outputcopy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>2 3 5 3 3 3 5 </code></td>\n<td><code>3.0 5.5</code></td>\n</tr>\n</tbody></table>\n<p>如果最大的电池大于其它电池总和，则答案为其它电池总和。</p>\n<p>否则一定有办法恰好消耗所有电量，则答案为总和一半。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\nconst int maxn &#x3D; 1100;\nint n, cg[maxn], sum, mx;\nint main()\n&#123;\n    while(scanf(&quot;%d&quot;, &amp;n) !&#x3D; EOF)\n    &#123;\n        sum &#x3D; mx &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; i ++)\n            scanf(&quot;%d&quot;, &amp;cg[i]), sum +&#x3D; cg[i], mx &#x3D; std::max(mx, cg[i]);\n        if(mx &lt;&lt; 1 &gt; sum) printf(&quot;%.1f\\n&quot;, 1.0 * (sum - mx));\n        else printf(&quot;%.1f\\n&quot;, sum * 0.5);\n    &#125;\n    return 0;\n&#125;</code></pre>\n\n<h3 id=\"F-最小新整数-OpenJ-Bailian-4137\"><a href=\"#F-最小新整数-OpenJ-Bailian-4137\" class=\"headerlink\" title=\"F - 最小新整数 OpenJ_Bailian - 4137\"></a>F - 最小新整数 <code>OpenJ_Bailian - 4137</code></h3><p>给定一个十进制正整数n(0 &lt; n &lt; 1000000000)，每个数位上数字均不为0。n的位数为m。<br>现在从m位中删除k位(0&lt;k &lt; m)，求生成的新整数最小为多少？<br>例如: n &#x3D; 9128456, k &#x3D; 2, 则生成的新整数最小为12456</p>\n<p><strong>Input</strong></p>\n<p>第一行t, 表示有t组数据；<br>接下来t行，每一行表示一组测试数据，每组测试数据包含两个数字n, k。</p>\n<p><strong>Output</strong></p>\n<p>t行，每行一个数字，表示从n中删除k位后得到的最小整数。</p>\n<p><strong>Sample</strong></p>\n<table>\n<thead>\n<tr>\n<th>Inputcopy</th>\n<th>Outputcopy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>2 9128456 2 1444 3 </code></td>\n<td><code>12456 1</code></td>\n</tr>\n</tbody></table>\n<p>每次从高位向低位找第一个比相邻低位大的位置，比如 <code>13245</code>，第一次操作去掉 <code>3</code>，因为<code>3</code>比相邻低位的<code>2</code>大，去掉<code>3</code>收益最高。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\nint n, k;\nint main()\n&#123;\n    int t;\n    for(scanf(&quot;%d&quot;, &amp;t); t --; )\n    &#123;\n        scanf(&quot;%d%d&quot;, &amp;n, &amp;k);\n        while(k --)\n        &#123;\n            int lst &#x3D; 1, l &#x3D; 1;\n            for(int i &#x3D; 10; i &lt; n; lst &#x3D; i, i *&#x3D; 10)\n                if(n &#x2F; i % 10 &gt; n &#x2F; lst % 10)\n                    l &#x3D; i;\n            n &#x3D; n &#x2F; l &#x2F; 10 * l + n % l;\n        &#125;\n        printf(&quot;%d\\n&quot;, n);\n    &#125;\n    return 0;\n&#125;</code></pre>\n\n<h3 id=\"G-田忌赛马-OpenJ-Bailian-4005\"><a href=\"#G-田忌赛马-OpenJ-Bailian-4005\" class=\"headerlink\" title=\"G - 田忌赛马 OpenJ_Bailian - 4005\"></a>G - 田忌赛马 <code>OpenJ_Bailian - 4005</code></h3><p>C和S两位同学一起玩拼点游戏。有一堆白色卡牌和一堆蓝色卡牌，每张卡牌上写了一个整数点数。C随机抽取n张白色卡牌，S随机抽取n张蓝色卡牌，他们进行n回合拼点，每次两人各出一张卡牌，点数大者获得三颗巧克力，小者获得一颗巧克力，如果点数相同，每人各得二颗巧克力，使用过的卡牌不得重复使用。已知C和S取到的卡牌点数，请编程计算S最多和最少能得到多少颗巧克力。</p>\n<p><strong>Input</strong></p>\n<p>输入包含多组测试数据。<br>每组测试数据的第一行是一个整数n(1&lt;&#x3D;n&lt;&#x3D;1000)，接下来一行是n个整数，表示C抽到的白色卡牌的点数，下一行也是n个整数，表示S抽到的蓝色卡牌的点数。<br>输入的最后以一个0表示结束。</p>\n<p><strong>Output</strong></p>\n<p>对每组数据，输出一行，内容是两个整数用空格格开，分别表示S最多和最少可获得的巧克力数。</p>\n<p><strong>Sample</strong></p>\n<table>\n<thead>\n<tr>\n<th>Inputcopy</th>\n<th>Outputcopy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>3 92 83 71 95 87 74 2 20 20 20 20 2 20 19 22 18 0</code></td>\n<td><code>9 5 4 4 4 4</code></td>\n</tr>\n</tbody></table>\n<p>贪心测策略：</p>\n<ol>\n<li>如果S当前最大的比C最大的大，直接比较</li>\n<li>如果S当前最大的比C最大的小，则用S当前最小的与C最大的比较</li>\n<li>如果S当前最大的与C最大的相等，则：<ol>\n<li>S最小的比C最小的大，则S最小的先和C最小的比较</li>\n<li>否则，S最小的与C最大的比较</li>\n</ol>\n</li>\n</ol>\n<p>总数减去反向田忌赛马即可求S最小结果</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\nconst int maxn &#x3D; 1100;\nint n, c[maxn], s[maxn];\nvoid Load(int x[])\n&#123;\n    for(int i &#x3D; 0; i &lt; n; i ++)\n        scanf(&quot;%d&quot;, &amp;x[i]);\n    std::sort(x, x + n);\n&#125;\nint TianJi(int x[], int y[])\n&#123;\n    int ret &#x3D; 0;\n    for(int il &#x3D; 0, ir &#x3D; n - 1, jl &#x3D; 0, jr &#x3D; n - 1; il &lt;&#x3D; ir;)\n    &#123;\n        if(x[ir] &gt; y[jr]) ret +&#x3D; 3, ir --, jr --;\n        else if(x[ir] &lt; y[jr]) ret +&#x3D; 1, il ++, jr --;\n        else\n        &#123;\n            if(x[il] &gt; y[jl]) ret +&#x3D; 3, il ++, jl ++;\n            else ret +&#x3D; (x[il] &#x3D;&#x3D; y[jr] ? 2 : 1), il ++, jr --;\n        &#125;\n    &#125;\n    return ret;\n&#125;\nint main()\n&#123;\n    while(scanf(&quot;%d&quot;, &amp;n) !&#x3D; EOF &amp;&amp; n)\n    &#123;\n        Load(c);\n        Load(s);\n        printf(&quot;%d %d\\n&quot;, TianJi(s, c), n * 4 - TianJi(c, s));\n\n    &#125;\n    return 0;\n&#125;</code></pre>\n\n<h3 id=\"H-线段-LibreOJ-10007\"><a href=\"#H-线段-LibreOJ-10007\" class=\"headerlink\" title=\"H - 线段 LibreOJ - 10007\"></a>H - 线段 <code>LibreOJ - 10007</code></h3><p><strong>题目描述</strong></p>\n<p>数轴上有 n<em>n</em> 条线段，选取其中 k<em>k</em> 条线段使得这 k<em>k</em> 条线段两两没有重合部分，问 k<em>k</em> 最大为多少。</p>\n<p><strong>输入格式</strong></p>\n<p>第一行为一个正整数 n<em>n</em>；</p>\n<p>在接下来的 n<em>n</em> 行中，每行有 22 个数 a_i, b_i<em>a**i</em>,<em>b**i</em>，描述每条线段。</p>\n<p><strong>输出格式</strong></p>\n<p>输出一个整数，为 k<em>k</em> 的最大值。</p>\n<p><strong>样例</strong></p>\n<table>\n<thead>\n<tr>\n<th>Inputcopy</th>\n<th>Outputcopy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>3 0 2 2 4 1 3</code></td>\n<td><code>2</code></td>\n</tr>\n</tbody></table>\n<p>电影节 <code>OpenJ_Bailian - 4151</code> 买一送一</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\nconst int maxn &#x3D; 1e6 + 10;\nstruct Node\n&#123;\n    int s, t;\n    bool operator&lt;(const Node&amp;that)const\n    &#123;\n        return t &lt; that.t;\n    &#125;\n&#125;;\nint n;\nNode mov[maxn];\nint main()\n&#123;\n    while(scanf(&quot;%d&quot;, &amp;n) !&#x3D; EOF)\n    &#123;\n        for(int i &#x3D; 0; i &lt; n; i ++)\n            scanf(&quot;%d%d&quot;, &amp;mov[i].s, &amp;mov[i].t);\n        std::sort(mov, mov + n);\n        int ans &#x3D; 0, nt &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; i ++)\n            if(mov[i].s &gt;&#x3D; nt) ans ++, nt &#x3D; mov[i].t;\n        printf(&quot;%d\\n&quot;, ans);\n    &#125;\n    return 0;\n&#125;</code></pre>\n\n<h3 id=\"I-智力大冲浪-LibreOJ-10004\"><a href=\"#I-智力大冲浪-LibreOJ-10004\" class=\"headerlink\" title=\"I - 智力大冲浪 LibreOJ - 10004\"></a>I - 智力大冲浪 <code>LibreOJ - 10004</code></h3><p><strong>题目描述</strong></p>\n<p>小伟报名参加中央电视台的智力大冲浪节目。本次挑战赛吸引了众多参赛者，主持人为了表彰大家的勇气，先奖励每个参赛者 m<em>m</em> 元。先不要太高兴！因为这些钱还不一定都是你的？！接下来主持人宣布了比赛规则：</p>\n<p>首先，比赛时间分为 n<em>n</em> 个时段，它又给出了很多小游戏，每个小游戏都必须在规定期限 t_i<em>t**i</em> 前完成。如果一个游戏没能在规定期限前完成，则要从奖励费 m<em>m</em> 元中扣去一部分钱 w_i<em>w**i</em>，w_i<em>w**i</em> 为自然数，不同的游戏扣去的钱是不一样的。当然，每个游戏本身都很简单，保证每个参赛者都能在一个时段内完成，而且都必须从整时段开始。主持人只是想考考每个参赛者如何安排组织自己做游戏的顺序。作为参赛者，小伟很想赢得冠军，当然更想赢取最多的钱！注意：比赛绝对不会让参赛者赔钱！</p>\n<p><strong>输入格式</strong></p>\n<p>输入共四行。</p>\n<p>第一行为 m<em>m</em>，表示一开始奖励给每位参赛者的钱；</p>\n<p>第二行为 n<em>n</em>，表示有 n<em>n</em> 个小游戏；</p>\n<p>第三行有 n<em>n</em> 个数，分别表示游戏 11 到 n<em>n</em> 的规定完成期限；</p>\n<p>第四行有 n<em>n</em> 个数，分别表示游戏 11 到 n<em>n</em> 不能在规定期限前完成的扣款数。</p>\n<p><strong>输出格式</strong></p>\n<p>输出仅一行，表示小伟能赢取最多的钱。</p>\n<p><strong>样例</strong></p>\n<table>\n<thead>\n<tr>\n<th>Inputcopy</th>\n<th>Outputcopy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>10000 7 4 2 4 3 1 4 6 70 60 50 40 30 20 10</code></td>\n<td><code>9950</code></td>\n</tr>\n</tbody></table>\n<p><code>n</code>个时间安排<code>n</code>个游戏，每个游戏有个截止时间。</p>\n<p>贪心策略： 既然每个时间都肯定会安排一个游戏，那么就看一看每个时间段安排哪个游戏。</p>\n<p>从第 <code>n</code> 个时间开始倒着枚举，看当前时间来得及做的（截止时间大于等于当前时间）的任务哪个最贵就安排上。</p>\n<p>枚举一轮之后，没安排上的那些任务就是一定会超期的，把这些加起来。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\nconst int maxn &#x3D; 550;\nstruct Node\n&#123;\n    int t, w;\n&#125;;\nint n, m;\nNode g[maxn];\nint main()\n&#123;\n    while(scanf(&quot;%d%d&quot;, &amp;m, &amp;n) !&#x3D; EOF)\n    &#123;\n        for(int i &#x3D; 0; i &lt; n; i ++)\n            scanf(&quot;%d&quot;, &amp;g[i].t);\n        for(int i &#x3D; 0; i &lt; n; i ++) \n            scanf(&quot;%d&quot;, &amp;g[i].w);\n        for(int i &#x3D; n; i &gt;&#x3D; 1; i --)\n        &#123;\n            int mx &#x3D; -1, mxj;\n            for(int j &#x3D; 0; j &lt; n; j ++)\n            &#123;\n                if(g[j].t &gt;&#x3D; i &amp;&amp; g[j].w &gt; mx)\n                    mxj &#x3D; j, mx &#x3D; g[j].w;\n            &#125;\n            if(mx !&#x3D; -1) g[mxj].w &#x3D; -1;\n        &#125;\n        for(int i &#x3D; 0; i &lt; n; i ++)\n            if(g[i].w !&#x3D; -1) m -&#x3D; g[i].w;\n        printf(&quot;%d\\n&quot;, m);\n\n    &#125;\n    return 0;\n&#125;</code></pre>\n\n<h3 id=\"J-Find-Amir-CodeForces-804A\"><a href=\"#J-Find-Amir-CodeForces-804A\" class=\"headerlink\" title=\"J - Find Amir CodeForces - 804A\"></a>J - Find Amir <code>CodeForces - 804A</code></h3><p>大雄和他女朋友决定在国庆出游n个城市，城市被标记成1到n，每两个城市之间的路费为（i+j）mod（n+1），他们可以从任意一个城市出发，求游玩这n个城市需要的最少费用为多少</p>\n<p><strong>Input</strong></p>\n<p>第一行包含一个整数<em>n</em> (1 ≤ <em>n</em> ≤ 105) — 城市个数</p>\n<p><strong>Output</strong></p>\n<p>打印单个整数：表示访问所有城市所需的最少花费。</p>\n<p><strong>Examples</strong></p>\n<p><strong>Input</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">2</code></pre>\n\n<p><strong>Output</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">0</code></pre>\n\n<p><strong>Input</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">10</code></pre>\n\n<p><strong>Output</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">4</code></pre>\n\n<p><strong>Note</strong></p>\n<p>In the first example we can buy a ticket between the schools that costs <img src=\"https://vj.csgrandeur.cn/cdf864b92f748661512f2652cd873738?v=1540032320\" alt=\"img\">.</p>\n<p><code>(1, n)</code>、<code>(2,n-1)</code>捉对路费为<code>0</code>，<code>n</code>跳到<code>2</code>路费为<code>1</code>，计算路费为<code>1</code>的次数。</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\nint n;\nint main()\n&#123;\n    while(scanf(&quot;%d&quot;, &amp;n) !&#x3D; EOF)\n        printf(&quot;%d\\n&quot;, (n - 1) &gt;&gt; 1);\n    return 0;\n&#125;</code></pre>\n","text":"A - 电影节 OpenJ_Bailian - 4151大学生电影节在北大举办! 这天，在北大各地放了多部电影，给定每部电影的放映时间区间，区间重叠的电影不可能同时看（端点可以重合），问李雷最多可以看多少部电影。 Input 多组数据。每组数据开头是n(n&lt;&#x3D;10...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#A-%E7%94%B5%E5%BD%B1%E8%8A%82-OpenJ-Bailian-4151\"><span class=\"toc-text\">A - 电影节 OpenJ_Bailian - 4151</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#B-%E6%95%B0%E5%88%97%E5%88%86%E6%AE%B5-LibreOJ-10006\"><span class=\"toc-text\">B - 数列分段 LibreOJ - 10006</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#C-%E5%9C%A3%E8%AF%9E%E8%80%81%E4%BA%BA%E7%9A%84%E7%A4%BC%E7%89%A9-Santa-Clau%E2%80%99s-Gifts-OpenJ-Bailian-4110\"><span class=\"toc-text\">C - 圣诞老人的礼物-Santa Clau’s Gifts OpenJ_Bailian - 4110</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#D-%E7%A7%8D%E6%A0%91-LibreOJ-10001\"><span class=\"toc-text\">D - 种树 LibreOJ - 10001</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#E-%E7%94%B5%E6%B1%A0%E7%9A%84%E5%AF%BF%E5%91%BD-OpenJ-Bailian-3468\"><span class=\"toc-text\">E - 电池的寿命 OpenJ_Bailian - 3468</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#F-%E6%9C%80%E5%B0%8F%E6%96%B0%E6%95%B4%E6%95%B0-OpenJ-Bailian-4137\"><span class=\"toc-text\">F - 最小新整数 OpenJ_Bailian - 4137</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#G-%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC-OpenJ-Bailian-4005\"><span class=\"toc-text\">G - 田忌赛马 OpenJ_Bailian - 4005</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#H-%E7%BA%BF%E6%AE%B5-LibreOJ-10007\"><span class=\"toc-text\">H - 线段 LibreOJ - 10007</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#I-%E6%99%BA%E5%8A%9B%E5%A4%A7%E5%86%B2%E6%B5%AA-LibreOJ-10004\"><span class=\"toc-text\">I - 智力大冲浪 LibreOJ - 10004</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#J-Find-Amir-CodeForces-804A\"><span class=\"toc-text\">J - Find Amir CodeForces - 804A</span></a></li></ol>","author":{"name":"Shockley","slug":"blog-author","avatar":"https://s1.ax1x.com/2022/10/27/xhKxMQ.jpg","link":"https://www.cnblogs.com/rock3t/","description":"菜鸟一枚，会发一些记录生活和学习笔记的小文章","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"步进电机驱动——DRV8825","uid":"a28f4f35d46de8d7918b8b2e0cb657d2","slug":"步进电机驱动——DRV8825","date":"2022-11-13T12:48:56.000Z","updated":"2022-11-24T13:00:27.756Z","comments":true,"path":"api/articles/步进电机驱动——DRV8825.json","keywords":null,"cover":[],"text":"步进电机驱动模块 DRV8825使用笔记步进电机工作原理步进电机使用带齿的轮和电磁铁来使论一次一步旋转 DRV8825步进电机驱动器芯片 m0 m1 m2 是微步引脚，简单来说，就是通过电平的高低控制步长 M0 M1 M2 微步分辨率 低 低 低 全步 高 低 低 半步 低 高 ...","link":"","photos":[],"count_time":{"symbolsCount":498,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Shockley","slug":"blog-author","avatar":"https://s1.ax1x.com/2022/10/27/xhKxMQ.jpg","link":"https://www.cnblogs.com/rock3t/","description":"菜鸟一枚，会发一些记录生活和学习笔记的小文章","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"FreeRTOS_队列管理","uid":"99298ce049ccdc06bc2b056b9a20c2b4","slug":"FreeRTOS-队列管理","date":"2022-11-04T13:37:18.000Z","updated":"2022-11-04T14:26:14.393Z","comments":true,"path":"api/articles/FreeRTOS-队列管理.json","keywords":null,"cover":"https://picx1.zhimg.com/v2-cacaa3d560e91f8431bb662924b3d3b1_1440w.jpg?source=172ae18b","text":"FreeRTOS队列管理全局变量和弊端在以往的教程中，我们创建的任务都是相对独立的，任务之间并没有互相通讯交换数据。有童鞋说当然可以通过定义一个全局变量来实现多任务之间共享数据呀。你有没有想过，如果有多个任务同时要对一个占多字节的全局变量进行修改，如果没有保护机制的话，当第一个任...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"嵌入式学习","slug":"嵌入式学习","count":2,"path":"api/tags/嵌入式学习.json"}],"author":{"name":"Shockley","slug":"blog-author","avatar":"https://s1.ax1x.com/2022/10/27/xhKxMQ.jpg","link":"https://www.cnblogs.com/rock3t/","description":"菜鸟一枚，会发一些记录生活和学习笔记的小文章","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}