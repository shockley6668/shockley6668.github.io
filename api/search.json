[{"id":"563aa1fc6f17a3a1184aeccab51ff935","title":"C语言oj心得_扫雪挑战","content":"扫雪挑战题目描述冬天到啦，住在南方城市的你可能从没见过下雪，但是住在北方城市的小明可犯了愁，他的家门口的街道堆满了雪！\n小明想要清理掉这些积雪，可是他一个人的力量不足以解决，于是他叫来了Q个工人帮忙\n但是这些工人有强迫症，他们只会清理从起点m到终点n的道路上的积雪（m，n均为整数，且m与n均会被清理）\n那么当经历了Q个工人清理积雪之后，还剩多长的道路上有积雪？\n你可以认为街道的长度从1开始\n其中1&lt;&#x3D;m&lt;&#x3D;n&lt;&#x3D;1000000\n输入街道的长度d\n工人的数目Q\n接下来有Q列，每一列输入一个工人清理的起点m与终点n\n输出剩下的没有被清理掉的积雪的长度\n输入样例\n1000\n3\n1 100\n200 300\n250 350\n\n输出样例\n749\n\n解题想法首先先定义一个结构体数组储存每个工人的起点和中点，接着对输入的每个工人的起点进行冒泡排序。因为是按照起点进行的排序的，所以必然会造成一个问题，就是下面第四点，如果上一个工人扫路的终点比上上个工人的起点还短，那么累计扫地的路段就是应该是end减去最长哪个last end，所以就要分别考虑各种情况，如下\n\n#include&lt;stdio.h&gt;\nint d,q;\ntypedef struct &#123;\n\tint end;\n\tint begin;\n&#125;eb;\neb gon[1000];\n\nint main()\n&#123;\n\tscanf(&quot;%d&quot;,&amp;d);\n\tscanf(&quot;%d&quot;,&amp;q);\n\tfor(int i&#x3D;0;i&lt;q;i++)\n\t&#123;\t\n\t\tscanf(&quot;%d%d&quot;,&amp;gon[i].begin,&amp;gon[i].end);\n\t&#125;\n\tfor(int i&#x3D;0;i&lt;q-1;i++)\n\t&#123;\n\t\tfor(int j&#x3D;0;j&lt;q-i-1;j++)\n\t\t&#123;\n\t\t\tif(gon[j].begin&gt;gon[j+1].begin)\n\t\t\t&#123;\n\t\t\t\teb temp;\n\t\t\t\ttemp&#x3D;gon[j];\n\t\t\t\tgon[j]&#x3D;gon[j+1];\n\t\t\t\tgon[j+1]&#x3D;temp;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tint ans&#x3D;gon[0].end-gon[0].begin+1;\n\tfor(int i&#x3D;1;i&lt;q;i++)\n\t&#123;\n\t\tif(gon[i-1].end&gt;gon[i].begin &amp;&amp; gon[i].end&gt;gon[i-1].end)\n\t\t\tans+&#x3D;gon[i].end-gon[i-1].end;\n\t\telse if(gon[i-1].end&lt;gon[i].begin)\n\t\t\tans+&#x3D;gon[i].end-gon[i].begin+1;\n\t\telse if(gon[i-1].end&#x3D;&#x3D;gon[i].begin)\n\t\t\tans+&#x3D;gon[i].end-gon[i].begin;\n\t\telse if (gon[i].end&lt;gon[i-1].end)\n\t\t\tgon[i].end&#x3D;gon[i-1].end; &#x2F;&#x2F;当end小于last end时，对last end进行赋值就能解决这个问题\n\t&#125;\n\tprintf(&quot;%d&quot;,d-ans);\n\treturn 0;\n&#125;\n","slug":"C语言oj心得","date":"2022-11-24T12:35:43.000Z","categories_index":"","tags_index":"","author_index":"Shockley"},{"id":"a28f4f35d46de8d7918b8b2e0cb657d2","title":"步进电机驱动——DRV8825","content":"步进电机驱动模块 DRV8825使用笔记步进电机工作原理步进电机使用带齿的轮和电磁铁来使论一次一步旋转\n\nDRV8825步进电机驱动器芯片\nm0 m1 m2 是微步引脚，简单来说，就是通过电平的高低控制步长\n\n\n\nM0\nM1\nM2\n微步分辨率\n\n\n\n低\n低\n低\n全步\n\n\n高\n低\n低\n半步\n\n\n低\n高\n低\n1&#x2F;4步\n\n\n高\n高\n低\n1&#x2F;8步\n\n\n低\n低\n高\n1&#x2F;16步\n\n\n高\n低\n高\n1&#x2F;32步\n\n\n低\n高\n高\n1&#x2F;32步\n\n\n高\n高\n高\n1&#x2F;32步\n\n\nstep引脚是控制电机的微步，每次检测到一个上升沿，就会按照你设置的微步来使电机运动，相应地，脉冲频率越快，电机旋转越快\nDIR引脚用于控制电机旋转方向，拉高顺时针，拉低逆时针转\nSLP&#x2F;SLEEP引脚为低电平有效输入。这意味着将该引脚拉至低电平可使驱动器进入睡眠模式，从而将功耗降至最低。特别是在不使用电动机以节省功率时，可以调用此方法。\n*vmot* 和 *GND MOT* 为电动机提供电源，该电源可以为8.2V至45V\nB2，B1，A1，A2 引脚为输出引脚\n","slug":"步进电机驱动——DRV8825","date":"2022-11-13T12:48:56.000Z","categories_index":"","tags_index":"","author_index":"Shockley"},{"id":"bc70f4e05aafed03ba0181aade8d3ac9","title":"贪心","content":"","slug":"贪心","date":"2022-11-10T01:38:30.000Z","categories_index":"","tags_index":"","author_index":"Shockley"},{"id":"99298ce049ccdc06bc2b056b9a20c2b4","title":"FreeRTOS_队列管理","content":"FreeRTOS队列管理全局变量和弊端在以往的教程中，我们创建的任务都是相对独立的，任务之间并没有互相通讯交换数据。有童鞋说当然可以通过定义一个全局变量来实现多任务之间共享数据呀。你有没有想过，如果有多个任务同时要对一个占多字节的全局变量进行修改，如果没有保护机制的话，当第一个任务赋值给全局变量赋值前几个字节后，如果此时调度器切换第二个任务执行给全局变量赋值另外的几个字节，那么这个全局变量的值就变得支离破碎毫无意义了。所以说使用全局变量其实是不太线程安全的，一种解决这个问题的方案就是采用队列。\n队列提供了一种任务间或者任务和中断间的通讯机制。\n\na图是采用进程间共享内存的方式，b图是采用消息队列的方式。\n通过进程间共享内存的方式，进程之间能够更快地共用和交互数据；消息队列则是提供了一种更通用且稳定的交互数据的方式。\n数据存储通常采用先进先出队列（FIFO）\n\n队列有如下两种实现方式：\n\n*复制队列（Queue by copy）* 表示写入队列的数据每个字节都被完整复制到队列中了，也叫值传递\n*引用队列（Queue by reference）* 表示写入队列的是要写入数据的引用（或者说是一个指针指向所引用的数据）而并不是数据本身\n\nFreeRTOS采用是复制队列的实现方式\n多任务访问和阻塞任何任务都可以往队列中发送东西\n出队阻塞当任务尝试从一个队列中读取数据的时候，但是这个队列啊，不一定有数据，那么现在有三种选择：1.继续执行下面的程序2.等一会3，死等。选哪一个就是由阻塞时间决定的.0就是不阻塞，设置为portMAX_DELAY的话，任务就会一直进入阻塞态等待，直到收到数据为止。\n入队阻塞任务向队列里面发消息，和出队阻塞一样，当一个任务向队列发消息的话也可以设置阻塞时间，比如任务B向队列Q发消息，队列Q是满的，情况就和上面的一样了。\n常见队列操作方法下面将介绍创建和使用队列需要用到的几个函数\nQueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize )\n\nxQueueCreate（）是创建队列用到的函数。函数的返回值是QueueHandle_t具柄类型，表示的是对所创建队列的一个引用句柄。FreeRTOS从FreeRTOS的堆中指定一些内存空间给队列使用。如果堆中没有足够空间给队列使用的话函数的返回值会是NULL。\n这个函数本质上是一个宏，用来创建动态队列，最终会调用函数xQUEUEGenericStatic()\n\nuxQueueLength 队列包含数据的最大长度\nuxItemSize 每个数据占用的字节大小\n\nBaseType_t xQueueSend( QueueHandle_t xQueue, const void * pvItemToQueue,\nTickType_t xTicksToWait )\n\nxQueueSend（）函数用于将数据发送到队列（具体一点就是队列的尾部）。如果要在中断程序调用的话需要使用xQueueSendFromISR（）函数。\n\nxQueue 队列的具柄，来自于xQueueCreate（）的返回值\npvItemToQueue 所发送数据的引用，然后这些数据会被复制到队列中\nxTicksToWait 队列如果满时发送任务的阻塞时间（block time），上文已经介绍过，可以通过pdMS_TO_TICKS()把时间转换成节拍数。如果设置为portMAX_DELAY的话任务将永远等待下去（需要FreeRTOSConfig.h头文件中INCLUDE_vTaskSuspend参数设置为1）\n返回值 发送数据成功时返回pdPASS，失败时返回errQUEUE_FULL\n\n下面两个函数用于明确指定发送数据到队列的头部还是尾部。\nBaseType_t xQueueSendToFront( QueueHandle_t xQueue, const void * pvItemToQueue,\nTickType_t xTicksToWait )\nBaseType_t xQueueSendToBack( QueueHandle_t xQueue, const void * pvItemToQueue,\nTickType_t xTicksToWait )\n\nxQueueSend（）函数和xQueueSendToBack（）函数本质上是一样的。\nBaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer,\nTickType_t xTicksToWait )\n\n\n\nxQueue 队列的具柄，来自于xQueueCreate（）的返回值\npvBuffer 指向内存空间的一个引用，读取的数据会被复制到这片内存\nxTicksToWait 队列如果空时接送任务的阻塞时间（block time），上文已经介绍过，可以通过pdMS_TO_TICKS()把时间转换成节拍数。如果设置为portMAX_DELAY的话任务将永远等待下去（需要FreeRTOSConfig.h头文件中INCLUDE_vTaskSuspend参数设置为1）\n返回值 接收数据成功时返回pdPASS，失败时返回errQUEUE_EMPTY\n\nUBaseType_t uxQueueMessagesWaiting( QueueHandle_t xQueue )\n\nuxQueueMessagesWaiting（）函数用于获得队列中数据的数量\n队列结构体","slug":"FreeRTOS-队列管理","date":"2022-11-04T13:37:18.000Z","categories_index":"","tags_index":"嵌入式学习","author_index":"Shockley"},{"id":"137114166de934a4dd5b894c333fbc29","title":"排序题目","content":"Description 1冒泡排序是一种常见的排序算法，本题要求用冒泡排序算法对一组正整数进行从小到大排序.\n从小到大输出排序好的数，数之间用空格分开，行尾没有多余的空格.\nInput多组测试数据，每组数据第一行为 n 表示有n 个数。第二行为n个空格隔开的500内的正整数.\n1 ≤ n ≤ 100.\nOutput从小到大输出这些正整数，空格隔开，行末没有多余的空格\nSample Input5\n6 7 2 4 3\n4\n9 2 4 1\n\nSample Output2 3 4 6 7\n1 2 4 9\n\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\nint a[110], n;\nvoid Swap(int &amp;a, int &amp;b) &#x2F;&#x2F;把真实地址传进去\n&#123;\n    int tmp &#x3D; a;\n    a &#x3D; b;\n    b &#x3D; tmp;\n&#125;\nint main()\n&#123;\n    for(n &#x3D; 0; scanf(&quot;%d&quot;, &amp;a[n]) !&#x3D; EOF; n ++);\n    for(int i &#x3D; n - 1; i &gt;&#x3D; 0; i --)\n        for(int j &#x3D; 0; j &lt; i; j ++)\n            if(a[j] &gt; a[j + 1]) Swap(a[j], a[j + 1]);\n    for(int i &#x3D; 0; i &lt; n; i ++)\n        printf(&quot; %d&quot; + !i, a[i]);\n    printf(&quot;\\n&quot;);\n    return 0;\n&#125;\n\nDescription 2一个都不大于500的非负整数序列，取出其中的奇数进行排序输出。\nInput多组测试数据，每组数据第一行为 n 表示有n 个数. 第二行为n个空格隔开的int范围内的正整数.\n1 ≤ n ≤ 100.\nOutput从小到大输出提供数据的奇数，空格隔开，行末没有多余的空格.\nSample Input5\n6 7 2 4 3\n4\n9 2 4 1\n\nSample Output3 7\n1 9\n\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nint a[1110], n, m, x;\nint main()\n&#123;\n    while(scanf(&quot;%d&quot;, &amp;n) !&#x3D; EOF)\n    &#123;\n        for(m &#x3D; 0; n --;)\n        &#123;\n            scanf(&quot;%d&quot;, &amp;x);\n            if(x &amp; 1) a[m ++] &#x3D; x;\n        &#125;\n        std::sort(a, a + m);\n        for(int i &#x3D; 0; i &lt; m; i ++)\n            printf(&quot;,%d&quot; + !i, a[i]); &#x2F;&#x2F;字符串就是一个首地址，加一的话就是第二个字符的地址，逗号就没了\n        printf(&quot;\\n&quot;);\n    &#125;\n    return 0;\n&#125;\n\n","slug":"排序题目","date":"2022-10-30T13:21:16.000Z","categories_index":"","tags_index":"ACM新手课堂练习","author_index":"Shockley"},{"id":"f4b64ea2c88bb417cb737aa4fba9997c","title":"uart学习","content":"串口简介（Universal Synchronous&#x2F;Asynchronous Receiver&#x2F;Transmitter）\n通用异步收发传输器（没有时钟线），相对地，有时钟线就是同步通信\n\n具有TX和RX两根线\n\n可以将数据串行地发送给对方\n\n\n\n\n\n\n\n\n\n串口数据按照位依次发送，同时只有一条信号线用于发送\n大多数协议都是串行的\n\n波特率：每秒钟串口发送的位速率\n\n常用115200，就是11.25kb&#x2F;s\n\nTX接RX，RX接TX\n\n可以同时发送和接收（全双工）\n\n一个数据包由起始位，结束位，数据位，校验位组成\n\n发送每一位的时长由波特率决定，停止位可以是一到两个时钟\n\n串口空闲时保持高电平\n\n数据位可以是5到九位，最低位LSB先发送，最高位MSB后发送\n\n\nUSART 通信协议\n\n起始位：当未有数据发送时，数据线处于逻辑“1”状态；先发出一个逻辑“0”信号，表示开始传输字 符。\n数据位：紧接着起始位之后。数据位的个数可以是4、5、6、7、8等，构成一个字符。通常采用 ASCII码。从最低位开始传送，靠时钟定位。\n奇偶校验位：数据为加上这一位后，使得“1”的位数应为偶数（偶校验）或奇数（奇校验），以此 来校验资料传送的正确性。\n停止位：它是一个字符数据的结束标志。可以是1位、1.5位、2位的高电平。 由于数据是在传输线 上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备间出现了小小的不同步。因 此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟同步的机会。适用于停止位的位数越 多，不同时钟同步的容忍程度越大，但是数据传输率同时也越慢。\n空闲位或起始位：处于逻辑“1”状态，表示当前线路上没有资料传送，进入空闲状态。处于逻辑“0” 状态，表示开始传送下一数据段。\n\nSTM32串口工作原理发送数据被写入串口外设，然后按照波特率依次发送数据并添加起始位和停止位\n接收串口外设可配置位以波特率的8倍或16倍的频率采样RX引脚上的电瓶，然后自动分析提取\n串口外设中断\nFIFO 溢出错误\n\n线中止错误（line-break，即Rx 信号一直为0 的状态，包括校验位和停止位在内）\n\n奇偶校验错误\n\n帧错误（停止位不为1）\n\n接收超时（接收FIFO 已有数据但未满，而后续数据长时间不来）\n\n发送\n\n接收\n\n\n实验部分本实验主要完成通过按键触发中断从串口一发送然后串口六接受\n预备知识（USART API）接收&#x2F;**\n* @brief Receives an amount of data in blocking mode.\n* @note When UART parity is not enabled (PCE &#x3D; 0), and Word Length is\nconfigured to 9 bits (M1-M0 &#x3D; 01),\n* the received data is handled as a set of u16. In this case, Size\nmust indicate the number\n* of u16 available through pData.\n* @param huart Pointer to a UART_HandleTypeDef structure that contains\n* the configuration information for the specified UART module.\n* @param pData Pointer to data buffer (u8 or u16 data elements).\n* @param Size Amount of data elements (u8 or u16) to be received.\n* @param Timeout Timeout duration\n* @retval HAL status\n*&#x2F;\nHAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData,\nuint16_t Size, uint32_t Timeout)\n\n阻塞式接受，等到直到超时\n&#x2F;**\n* @brief Receives an amount of data in non blocking mode.\n* @note When UART parity is not enabled (PCE &#x3D; 0), and Word Length is\nconfigured to 9 bits (M1-M0 &#x3D; 01),\n* the received data is handled as a set of u16. In this case, Size\nmust indicate the number\n* of u16 available through pData.\n* @param huart Pointer to a UART_HandleTypeDef structure that contains\n* the configuration information for the specified UART module.\n* @param pData Pointer to data buffer (u8 or u16 data elements).\n* @param Size Amount of data elements (u8 or u16) to be received.\n* @retval HAL status\n*&#x2F;\nHAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)\n\n中断式接受\n&#x2F;**\n* @brief Receives an amount of data in DMA mode.\n* @note When UART parity is not enabled (PCE &#x3D; 0), and Word Length is\nconfigured to 9 bits (M1-M0 &#x3D; 01),\n* the received data is handled as a set of u16. In this case, Size\nmust indicate the number\n* of u16 available through pData.\n* @param huart Pointer to a UART_HandleTypeDef structure that contains\n* the configuration information for the specified UART module.\n* @param pData Pointer to data buffer (u8 or u16 data elements).\n* @param Size Amount of data elements (u8 or u16) to be received.\n* @note When the UART parity is enabled (PCE &#x3D; 1) the received data contains\nthe parity bit.\n* @retval HAL status\n*&#x2F;\nHAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t* pData, uint16_t Size)\n\n使用DMA中断进行接收\n发送&#x2F;**\n* @brief Sends an amount of data in blocking mode.\n* @note When UART parity is not enabled (PCE &#x3D; 0), and Word Length is\nconfigured to 9 bits (M1-M0 &#x3D; 01),\n* the sent data is handled as a set of u16. In this case, Size must\nindicate the number\n* of u16 provided through pData.\n* @param huart Pointer to a UART_HandleTypeDef structure that contains\n* the configuration information for the specified UART module.\n* @param pData Pointer to data buffer (u8 or u16 data elements).\n* @param Size Amount of data elements (u8 or u16) to be sent\n* @param Timeout Timeout duration\n* @retval HAL status\n*&#x2F;\nHAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData,\nuint16_t Size, uint32_t Timeout)\n\n\n\n\n&#x2F;**\n* @brief Sends an amount of data in non blocking mode.\n* @note When UART parity is not enabled (PCE &#x3D; 0), and Word Length is\nconfigured to 9 bits (M1-M0 &#x3D; 01),\n* the sent data is handled as a set of u16. In this case, Size must\nindicate the number\n* of u16 provided through pData.\n* @param huart Pointer to a UART_HandleTypeDef structure that contains\n* the configuration information for the specified UART module.\n* @param pData Pointer to data buffer (u8 or u16 data elements).\n* @param Size Amount of data elements (u8 or u16) to be sent\n* @retval HAL status\n*&#x2F;\nHAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t\n*pData, uint16_t Size)\n\n&#x2F;**\n* @brief Sends an amount of data in DMA mode.\n* @note When UART parity is not enabled (PCE &#x3D; 0), and Word Length is\nconfigured to 9 bits (M1-M0 &#x3D; 01),\n* the sent data is handled as a set of u16. In this case, Size must\nindicate the number\n* of u16 provided through pData.\n* @param huart Pointer to a UART_HandleTypeDef structure that contains\n* the configuration information for the specified UART module.\n* @param pData Pointer to data buffer (u8 or u16 data elements).\n* @param Size Amount of data elements (u8 or u16) to be sent\n* @retval HAL status\n*&#x2F;\nHAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t\n*pData, uint16_t Size)\n\n\n中断void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart);\nvoid HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart);\n\n\n我写的首先使能串口接收HAL_UART_Receive_IT(&amp;huart6,rxDatabuffer,sizeof(rxDatabuffer)); &#x2F;&#x2F; 触发接受后，hal库会一只去等，直到他接受到这个数据，然后进入中断回调函数\n\n然后编写按键中断&#x2F;&#x2F;按键中断\nvoid HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)\n&#123;\n    if(GPIO_Pin &#x3D;&#x3D; GPIO_PIN_0)\n    &#123;\n        uint32_t temp&#x3D;HAL_GetTick();\n\n        *((uint32_t *)txDatabuffer)&#x3D;temp; &#x2F;&#x2F;强制类型转换，把强制转换位uint32位的指针，前面再加一个*进行。。\n        while(huart1.gState !&#x3D;HAL_UART_STATE_READY);&#x2F;&#x2F; 防止还没发送完成串口被占用的时候继续发送数据\n        HAL_UART_Transmit_IT(&amp;huart1,txDatabuffer,sizeof(txDatabuffer)); &#x2F;&#x2F;串口的发送\n\n    &#125;\n&#125;\n\n接着编写串口接受完成中断void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)\n&#123;\n    HAL_GPIO_TogglePin(GPIOH,GPIO_PIN_10);\n    HAL_GPIO_TogglePin(GPIOH,GPIO_PIN_11);\n    HAL_GPIO_TogglePin(GPIOH,GPIO_PIN_12);\n    if(huart&#x3D;&#x3D;&amp;huart6)\n    &#123;\n        rxdata&#x3D;*((uint32_t*)rxDatabuffer);\n        HAL_UART_Receive_IT(&amp;huart6,rxDatabuffer,sizeof(rxDatabuffer)); &#x2F;&#x2F;因为触发中断后就会没有，所以还要再次触发一次中断函数\n    &#125;\n&#125;\n\n值得注意的是这个指针的强制类型转换很妙\n接线部分\n编程环境clion+cubeMX+cubemonitor\n时钟树\nSTM32的所有外设都是可以配置时钟的\n大部分外设挂载在APB总线上，它们的时钟频率等于总线频率\n部分外设可以单独设置时钟频率\n\n\n因为只有uart1和6是挂载在APB2上的，所以他们的波特率可以设得很高，而挂载在APB1的不行\n","slug":"uart学习","date":"2022-10-28T07:49:26.000Z","categories_index":"","tags_index":"嵌入式学习","author_index":"Shockley"},{"id":"bd2189ae81127890cb8b79118f0d3213","title":"sort 算法","content":"Swap交换函数void swap(int &amp;a,int &amp;b)\n&#123;\n\tint temp&#x3D;a;\n\ta&#x3D;b;\n\tb&#x3D;temp;\n&#125;\n\nvoid swap(int &amp;a,int &amp;b) 为什么要加&amp;符号？？\n参数里的&amp;表示引用型参数，在一般的参数传递的时候，形参是实参的副本，也就是说形参和实参在内存中的位置不同，用了引用型参数后，形参和实参在内存中的位置是一样的。**&amp; 这里表示引用，说明需要传递变量给这个函数，函数中可以对参数的值进行修改如果没有 &amp;，修改的就是函数体中的临时变量。**\n冒泡排序void bubble_sort(int* arr,int len)\n&#123;\n\tfor(int i&#x3D;0;i&lt;len-1;i++)\n\t&#123;\n\t\tfor(int k&#x3D;0;k&lt;len-1-i;k++)\n\t\t&#123;\n\t\t\tif(arr[k]&gt;arr[k+1]) &#x2F;&#x2F;表示从小到大排\n\t\t\t&#123;\n\t\t\t\tswap(arr[k],arr[k+1]);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n冒泡排序的时间复杂度为O（n^2）\n插入排序insertion sort 每次从未排序中取出一个元素插入到已排序序列中，不断重复直至所有元素均被移到排序序列\n\n\nvoid insertion_sort (int arr[], int len)\n&#123;\n\tint j,key;\n\tfor(int i&#x3D;1;i&lt;len;i++)\n\t&#123;\n\t\tkey&#x3D;arr[i];\n\t\tj&#x3D;i-1;\n\t\twhile(j&gt;&#x3D;0 &amp;&amp; (arr[j]&gt;key))\n\t\t&#123;\n\t\t\tarr[j+1]&#x3D;arr[j]; &#x2F;&#x2F;移位，留出插入空格\n\t\t\tj--;\n\t\t&#125;\n\t\tarr[j+1]&#x3D;key; &#x2F;&#x2F;把新元素插入到空格中，+1是因为*\n\t&#125;\n&#125;\n\n\nwhile中j要大于0原因是处理临界条件，如果key比较到第一个都不比它大的话就要插在第一个前面了，第一个移到后面\narr[j+1]是因为如果当j&#x3D;0时进入循环j就等于-1，然后最后赋值要把j加一才行\n第一层for循环是为了选择要插入的数\n第二层while是为了判断插入到哪里，并且移位\n\n归并排序归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。\n作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：\n\n自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；\n自下而上的迭代；\n\n算法步骤\nvoid merge(int* arr,int left ,int middle,int right)\n&#123;\n\tint i&#x3D;left;\n\tint j&#x3D;middle;\n\tint * temp&#x3D;(int *)malloc((right-left)*4);\n\tint index&#x3D;0;\n\twhile(i&lt;middle &amp;&amp; j&lt;right)\n\t\ttemp[index++]&#x3D;arr[i]&lt;arr[j]?arr[i++]:arr[j++];\n\twhile(i&lt;middle)\n\t\ttemp[index++]&#x3D;arr[i++];\n\twhile(j&lt;right)\n\t\ttemp[index++]&#x3D;arr[j++];\n\tfor(int i&#x3D;0;i&lt;index;i++)\n\t\tarr[left+i]&#x3D;temp[i];\n\tfree(temp);\n&#125;\nvoid merge_sort(int* arr,int left ,int right)\n&#123;\n\tif(right-left&lt;&#x3D;1) return;\n\tint middle&#x3D;(left+right)&gt;&gt;1; \n\tmerge_sort(arr,left,middle);\n\tmerge_sort(arr,middle,right);\n\tmerge(arr,left,middle,right);\n\t\n&#125;\n\n递归而言，首先肯定 要给出递归结束条件(right-left&lt;&#x3D;1),，递归的结束条件一定是：原最小子问题的解！！！而这里，当递归到最后一步时候，子数组只剩一下一个元素，而这个元素本身就是有序的，所以直接return即可（在其他问题中没准需要你给出最小子问题的解）\n递归函数和普通函数本质是一致的，并无本质区别，当发生自己调用自己的时候，你完全可以认为，它调用了一个其他函数，只是这个函数好像和自己长得一模一样，俗称双胞胎。并且和普通调用一样，每个调用都会生成一个独立的栈空间，因此，mid值并不是只有一个mid,而是在每个调用体里都有一个mid只存在自己的栈空间。\n因此，这里说明关于递归调用的两点：\n\n递归调用和普通函数调用并无区别，你可以把递归调用想成调用了一个和自己长得一样的其他函数；\n既然是函数调用，栈空间就是独立的，哪怕它是递归调用，也是如此；\n\nC++ std::sort()实际写代码时很少手撸排序算法，因为 STL 已经为我们提供了方便好用的库函数 std::sort() ，该函数定义在头文件  中。\n食用方法该函数的基本用法为：\nstd::sort(s, s+n);\n\n其中 s 为需要排序的数组， n 为需要排序的区间长度。该函数传入的参数为两个指针，用于指定排序的范围 [L, R)。例如对长度为 5 的数组进行排序：注意，如果数组从第 1 位开始保存数据，那么排序时也要相应的偏移 1 位：\nstd::sort(s+1, s+n+1);\n\n自定义排序顺序sort() 函数默认情况下是按从小到大的顺序排序的，如果我们想从大到小排序或者对结构体排序，就需要向 sort() 指定我们期望的排序规则\n使用标准库比较函数如果只是想简单地将数组从大到小排序，标准库自带的比较函数就可以满足需求。\n   #include      &#x2F;&#x2F; std::cout    #include    &#x2F;&#x2F; std::greater    #include     &#x2F;&#x2F; std::sort\nint main () &#123;\n  int numbers[]&#x3D;&#123;20,40,50,10,30&#125;;\n  std::sort (numbers, numbers+5, std::greater&lt;int&gt;());\n  for (int i&#x3D;0; i&lt;5; i++)\n    std::cout &lt;&lt; numbers[i] &lt;&lt; &#39; &#39;;\n  std::cout &lt;&lt; &#39;\\n&#39;;\n  return 0;\n&#125;\n自定义比较函数自定义排序顺序的一种方法是向 sort() 多传入一个比较函数作为参数。比较函数是返回值为（或可转化为） bool 类型的双参函数，它定义了元素之间的严格弱序关系，当参数 1 优先于参数 2 时返回true ，反之返回 false \n#include&lt;cstdlib&gt;\n#include &lt;algorithm&gt;    \nint n&#x3D;10;\nstruct node\n&#123;\n\tint price, weight, value; &#x2F;&#x2F;价格、重量、价值\n&#125;;\nbool cmp1(const node &amp;a, const node &amp;b) &#x2F;&#x2F;规则1，按价格从小到大排序\n&#123;\n\treturn a.price &lt; b.price;\n&#125;\nbool cmp2(const node &amp;a, const node &amp;b) &#x2F;&#x2F;规则2，按价值从大到小排序\n&#123;\n\treturn a.value &gt; b.value;\n&#125;\n&#x2F;&#x2F;规则3，多关键字排序\n&#x2F;&#x2F;先按价值从大到小排序\n&#x2F;&#x2F;如果价值相同则按价格从小到大排序\n&#x2F;&#x2F;如果价值、价格都相同，则按重量从小到大排序\nbool cmp3(const node &amp;a, const node &amp;b)\n&#123;\n\tif (a.value &#x3D;&#x3D; b.value &amp;&amp; a.price &#x3D;&#x3D; b.price) return a.weight &lt; b.weight;\n\tif (a.value &#x3D;&#x3D; b.value) return a.price &lt; b.price;\n\treturn a.value &gt; b.value;\n&#125;\nnode s[105];\nint main()\n&#123;\n\tstd::sort(s, s+n, cmp1); &#x2F;&#x2F;使用规则1排序\n\tstd::sort(s, s+n, cmp2); &#x2F;&#x2F;使用规则2排序\n\tstd::sort(s, s+n, cmp3);&#x2F;&#x2F;使用规则3排序\n\treturn 0;\n&#125;\n\n","slug":"sort","date":"2022-10-28T02:38:18.000Z","categories_index":"","tags_index":"ACM新手课堂练习","author_index":"Shockley"},{"id":"ba06baf3033674352e99290bfc5eedc6","title":"python 类学习笔记","content":"_ _init _ _创建classclass Dog:\n    def __init__(self,name,breed,age):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\na_dog&#x3D;Dog(&quot;abc&quot;,&quot;hound&quot;,3)\nprint(a_dog.age,a_dog.breed,a_dog.name)\n\n在类中定义函数class Dog:\n    def __init__(self,name,breed,age):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\n    def age_promote(self):\n        self.age+&#x3D;1\na_dog&#x3D;Dog(&quot;abc&quot;,&quot;hound&quot;,3)\nprint(a_dog.age,a_dog.breed,a_dog.name)\na_dog.age_promote()\nprint(a_dog.age)\n\n_ _str _ _def __str__(self):\n    &quot;&quot;&quot;返回一个对象的描述信息&quot;&quot;&quot;\n    # print(num)\n    return &quot;名字是:%s , 年龄是:%d&quot; % (self.name, self.age)\n\n变长参数列表语法\ndef function_name(fixed_arg,*args):\n    statements\n\narg可以是元组或列表\n*的意思是变长参数列表，即参数可能不确定\neg1：\nclass Dog:\n    def __init__(self,name,breed,age,*arg):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\n        self.list&#x3D;arg\n    def age_promote(self):\n        self.age+&#x3D;1\n    def print_arg(self):\n        for i in self.list:\n            print(i)\na_dog&#x3D;Dog(&quot;abc&quot;,&quot;hound&quot;,3,1,2,3)\na_dog.print_arg()\n\n输出1 2 3\neg2：\nclass Dog:\n    def __init__(self,name,breed,age,*arg):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\n        self.list&#x3D;arg\n    def age_promote(self):\n        self.age+&#x3D;1\n    def print_arg(self):\n        for i in self.list:\n            print(i)\na_dog&#x3D;Dog(&quot;abc&quot;,&quot;hound&quot;,3,[1,2,3])\na_dog.print_arg()\n\n输出[1,2,3]\neg3：\nclass Dog:\n    def __init__(self,name,breed,age,*arg):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\n        self.list&#x3D;arg\n    def age_promote(self):\n        self.age+&#x3D;1\n    def print_arg(self):\n        for i in self.list:\n            print(i)\na_dog&#x3D;Dog(&quot;abc&quot;,&quot;hound&quot;,3,*[1,2,3])\na_dog.print_arg()\n\n输出1 2 3（同eg1）\n继承一个类继承另一个类时，继承者是子类，被继承者是父类\nclass class_name(base_class):\n    class_definition\n\neg1:\nclass Dog:\n    def __init__(self,name,breed,age,*arg):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\n        self.list&#x3D;arg\n    def age_promote(self):\n        self.age+&#x3D;1\n    def print_arg(self):\n        for i in self.list:\n            print(i)\nclass cat(Dog):\n    def play(self):\n        s&#x3D;&#39;&#39;\n        while not s or s[0] in &#39;Nn&#39;:\n            print(self.name,&#39;fetches the balls!&#39;)\n            s&#x3D;input(&#39;wanna play again？(Y&#x2F;N)&#39;)\nclass puppy(cat):\n    def __init__(self,name,breed,age,sitdown):\n        cat.__init__(self,name,breed,age)\n        self.sitdown&#x3D;0\n    def sit(self):\n        if (self.sitdown&#x3D;&#x3D;0):\n            print(&quot;I am sitting down!&quot;)\n            self.sitdown&#x3D;1\n        else:\n            print(&quot;i am stand up&quot;)\n            self.sitdown&#x3D;0\na_dog&#x3D;Dog(&quot;abc&quot;,&quot;hound&quot;,3,*[1,2,3])\na_dog.print_arg()\npu&#x3D;puppy(&quot;abc&quot;,&quot;hound&quot;,3,0)\npu.sit()\npu.sit()\na_cat&#x3D;cat(&quot;abc&quot;,&quot;hound&quot;,3,*[1,2,3])\na_cat.play()\n\ncat 和puppy就是dog的子类\n在python中都有子类自动继承超类的方法，继承可以是直接的也可以是间接的，在这里puppy直接继承了cat类的所有方法，还继承了祖父类dog的所有属性\n子类继承了父类的所有方法，其中包括__init__ ，因此不是在所有时候都要重新编写__init__方法\n但也可以像上面puppy类这么写\n类变量和类方法类变量是由同一个类的所有成员共享的变量\neg1:\nclass Dog:\n    num_dogs&#x3D;0;\n    def __init__(self,name,breed,age):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\n        Dog.num_dogs+&#x3D;1\na_dog&#x3D;Dog(&quot;first_dog&quot;,&#39;ww&#39;,3)\nprint(&quot;dog_num: &quot;,Dog.num_dogs)\nanother_dog&#x3D;Dog(&quot;second_dog&quot;,&quot;ee&quot;,3)\nprint(&quot;Now_dog_num :&quot;,Dog.num_dogs)\n\n输出\ndog_num:  1\nNow_dog_num : 2\n\n实例变量在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的\nclass Address:\n    detail &#x3D; &quot;guangzhou&quot;\n    post_code &#x3D; &quot;510660&quot;\n    def info(self):\n        #尝试直接访问类变量\n        #print(detail) #报错\n\n        #通过类类访问类变量\n        print(Address.detail)\n        print(Address.post_code)\n\n#通过类来访问Address 类的类变量\nprint(Address.detail)\naddr &#x3D; Address()\naddr.info()\n#修改Address类的类变量\nAddress.detail &#x3D; &quot;fushan&quot;\n\nAddress.post_code &#x3D; &quot;460110&quot;\naddr.info()\n\n","slug":"Python类","date":"2022-10-27T13:17:47.000Z","categories_index":"","tags_index":"","author_index":"Shockley"},{"id":"61e647d1d27f6d8af1fd2619625e8201","title":"数组学习","content":"创建一维vectorvector&lt;int&gt; nums;&#x2F;&#x2F;不指定长度\nvector&lt;int&gt; nums(n); &#x2F;&#x2F; 指定长度为n \n\n添加元素nums.push_back(1);&#x2F;&#x2F;直接从数组末端添加\nnums[i] &#x3D; 1;&#x2F;&#x2F;直接赋值给第i个位置\n\n删除元素nums.resize(nums.size-i); &#x2F;&#x2F;直接将数组长度减小，某种方式上删掉了后面i个\nnums.pop_back();&#x2F;&#x2F;删掉最后一个元素\n\n遍历数组for(int i &#x3D; 0; i &lt; nums.size(); i++)&#123;\n    cout&lt;&lt;nums[i]&lt;&lt;endl;\n&#125;\n\n创建二维动态数组vector&lt;vector &lt;int&gt; &gt; nums(m ,vector&lt;int&gt;(n));    &#x2F;&#x2F;m*n的二维vector\n\n","slug":"数组学习","date":"2022-10-27T13:17:47.000Z","categories_index":"","tags_index":"","author_index":"Shockley"},{"id":"bf4eea2954747cade91d710bb8265d76","title":"结构体 共用体","content":"typedef 用于创建已定义的数据类型的别名\n共用体 与结构体类似，但是其中的成员公用一个储存空间\n位运算符 用于处理整数中的数位\n位域 结构体的整形或无符号型成员变量，实现数据的压缩存储\n枚举 用标识符表示的一组整形变量\n结构体（aggregate）结构体可以包含不同数据类型的变量，将指针与结构体联合使用，可以实现更复杂的数据结构，如：链表，队列，堆栈和树\nfor example\nstruct employee&#123;\n\tchar firstname[20];\n\tchar lastname[20];\n\tunsigned int age;\n\tchar gender;\n\tdouble hourlySaraly;\n&#125;;\n\n结构体的定义关键字 struct\n结构体的自引用结构体不能包含他的自身类型，但是指向同一个结构体的指针却可以出现在结构体的定义中\n称为自引用结构体，可构成链式结构\nstruct employee2&#123;\n\tchar firstname[20];\n\tchar lastname[20];\n\tunsigned int age;\n\tchar gender;\n\tdouble hourlySaraly;\n&#x2F;&#x2F;\tstruct employee2 teamleader; error\n\tstruct employee2 *teamleader; &#x2F;&#x2F;pointer\n&#125;;\n\n定义结构体的类型变量结构体的定义并不占用内存中的任何空间，它只是创建了一种新的可以用来定义变量的数据类型。\n下面是定义结构体变量的两种方式\nstruct card&#123;\n\tchar *face;\n\tchar *suit;\n&#125;;\nstruct card aCard ,deck[52],*cardPtr;\n\nstruct card&#123;\n\tchar *face;\n\tchar *suit;\n&#125;aCard ,deck[52],*cardPtr;\n\n执行完上面语句后，系统才为一个类型为struct card 的变量申请aCard、数组deck中的52个struct card和一个未初始化的指向struct card 类型的指针申请空间\n结构体标记名结构体标记名可以省略，但是省略时，结构体类型变量的声明就只能和结构体定义同时进行\n结构体初始化与数组一样，可以采用初始值列表来初始化结构体\nStructures can be initialized using initializer lists as with arrays. To initialize a structure, follow the variable name in the definition with an equals sign and a brace-enclosed, comma-separated list of initializers. For example, the declaration.\nstruct card aCard &#x3D; &#123; &quot;Three&quot;, &quot;Hearts&quot; &#125;;\n\n用.和 -&gt;访问结构体成员有两种运算符来访问结构体的成员：\n结构体成员运算符  structure member operator   ( . )\n结构体指针运算符 structure pointer operator -&gt;\n例如：\nprintf(&quot;%s&quot;, aCard.suit); &#x2F;&#x2F; displays Hearts\n\n假设cardPtr是struct card类型的指针并且指向acard\n则有：\nprintf(&quot;%s&quot;, cardPtr-&gt;suit); &#x2F;&#x2F; displays Hearts\n\nattention :The expression cardPtr-&gt;suit is equivalent to **(cardPtr).suit*\naCard.face&#x3D;&quot;ACE&quot;;\naCard.suit&#x3D;&quot;Spades&quot;;\ncardPtr&#x3D;&amp;aCard;\nprintf(&quot;%s%s%s&quot;,aCard.face,cardPtr-&gt;face,(*cardPtr).face);\n\n在函数中使用结构体\n传递结构体的个别成员\nWhen structures or individual structure members are passed to a function, they’re passed by value. Therefore, the members of a caller’s structure cannot be modified by the called function\n\n传递整个结构体\n\n传递指向结构体的指针\n\n\ntypedef 的使用typedef struct card Card;\n\nCard can now be used to declare variables of type struct card. The declaration\nCard deck[52];\ndeclares an array of 52 Card structures.\n\n\n\n\n\n\n\n\n\nCreating a new name with typedef does not create a new type;typedef simply creates a new type name, which may be used as an alias for an existing type name.\n位运算符\n","slug":"结构体 共用体 位操作和枚举类型","date":"2022-10-27T13:17:47.000Z","categories_index":"","tags_index":"","author_index":"Shockley"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\n编译hexo cl &amp;&amp; hexo g\n\nuploadhexo d\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-10-27T09:56:39.080Z","categories_index":"","tags_index":"","author_index":"Shockley"}]