[{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"","slug":"Untitled","date":"2022-10-28T15:09:52.128Z","categories_index":"","tags_index":"","author_index":"Shockley"},{"id":"f4b64ea2c88bb417cb737aa4fba9997c","title":"uart学习","content":"串口简介（Universal Synchronous&#x2F;Asynchronous Receiver&#x2F;Transmitter）\n通用异步收发传输器（没有时钟线），相对地，有时钟线就是同步通信\n\n具有TX和RX两根线\n\n可以将数据串行地发送给对方\n\n\n\n\n\n\n\n\n\n串口数据按照位依次发送，同时只有一条信号线用于发送\n大多数协议都是串行的\n\n波特率：每秒钟串口发送的位速率\n\n常用115200，就是11.25kb&#x2F;s\n\nTX接RX，RX接TX\n\n可以同时发送和接收（全双工）\n\n一个数据包由起始位，结束位，数据位，校验位组成\n\n发送每一位的时长由波特率决定，停止位可以是一到两个时钟\n\n串口空闲时保持高电平\n\n数据位可以是5到九位，最低位LSB先发送，最高位MSB后发送\n\n\nUSART 通信协议\n\n起始位：当未有数据发送时，数据线处于逻辑“1”状态；先发出一个逻辑“0”信号，表示开始传输字 符。\n数据位：紧接着起始位之后。数据位的个数可以是4、5、6、7、8等，构成一个字符。通常采用 ASCII码。从最低位开始传送，靠时钟定位。\n奇偶校验位：数据为加上这一位后，使得“1”的位数应为偶数（偶校验）或奇数（奇校验），以此 来校验资料传送的正确性。\n停止位：它是一个字符数据的结束标志。可以是1位、1.5位、2位的高电平。 由于数据是在传输线 上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备间出现了小小的不同步。因 此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟同步的机会。适用于停止位的位数越 多，不同时钟同步的容忍程度越大，但是数据传输率同时也越慢。\n空闲位或起始位：处于逻辑“1”状态，表示当前线路上没有资料传送，进入空闲状态。处于逻辑“0” 状态，表示开始传送下一数据段。\n\nSTM32串口工作原理发送数据被写入串口外设，然后按照波特率依次发送数据并添加起始位和停止位\n接收串口外设可配置位以波特率的8倍或16倍的频率采样RX引脚上的电瓶，然后自动分析提取\n串口外设中断\nFIFO 溢出错误\n\n线中止错误（line-break，即Rx 信号一直为0 的状态，包括校验位和停止位在内）\n\n奇偶校验错误\n\n帧错误（停止位不为1）\n\n接收超时（接收FIFO 已有数据但未满，而后续数据长时间不来）\n\n发送\n\n接收\n\n\n实验部分本实验主要完成通过按键触发中断从串口一发送然后串口六接受\n预备知识（USART API）接收&#x2F;**\n* @brief Receives an amount of data in blocking mode.\n* @note When UART parity is not enabled (PCE &#x3D; 0), and Word Length is\nconfigured to 9 bits (M1-M0 &#x3D; 01),\n* the received data is handled as a set of u16. In this case, Size\nmust indicate the number\n* of u16 available through pData.\n* @param huart Pointer to a UART_HandleTypeDef structure that contains\n* the configuration information for the specified UART module.\n* @param pData Pointer to data buffer (u8 or u16 data elements).\n* @param Size Amount of data elements (u8 or u16) to be received.\n* @param Timeout Timeout duration\n* @retval HAL status\n*&#x2F;\nHAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData,\nuint16_t Size, uint32_t Timeout)\n\n阻塞式接受，等到直到超时\n&#x2F;**\n* @brief Receives an amount of data in non blocking mode.\n* @note When UART parity is not enabled (PCE &#x3D; 0), and Word Length is\nconfigured to 9 bits (M1-M0 &#x3D; 01),\n* the received data is handled as a set of u16. In this case, Size\nmust indicate the number\n* of u16 available through pData.\n* @param huart Pointer to a UART_HandleTypeDef structure that contains\n* the configuration information for the specified UART module.\n* @param pData Pointer to data buffer (u8 or u16 data elements).\n* @param Size Amount of data elements (u8 or u16) to be received.\n* @retval HAL status\n*&#x2F;\nHAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)\n\n中断式接受\n&#x2F;**\n* @brief Receives an amount of data in DMA mode.\n* @note When UART parity is not enabled (PCE &#x3D; 0), and Word Length is\nconfigured to 9 bits (M1-M0 &#x3D; 01),\n* the received data is handled as a set of u16. In this case, Size\nmust indicate the number\n* of u16 available through pData.\n* @param huart Pointer to a UART_HandleTypeDef structure that contains\n* the configuration information for the specified UART module.\n* @param pData Pointer to data buffer (u8 or u16 data elements).\n* @param Size Amount of data elements (u8 or u16) to be received.\n* @note When the UART parity is enabled (PCE &#x3D; 1) the received data contains\nthe parity bit.\n* @retval HAL status\n*&#x2F;\nHAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t* pData, uint16_t Size)\n\n使用DMA中断进行接收\n发送&#x2F;**\n* @brief Sends an amount of data in blocking mode.\n* @note When UART parity is not enabled (PCE &#x3D; 0), and Word Length is\nconfigured to 9 bits (M1-M0 &#x3D; 01),\n* the sent data is handled as a set of u16. In this case, Size must\nindicate the number\n* of u16 provided through pData.\n* @param huart Pointer to a UART_HandleTypeDef structure that contains\n* the configuration information for the specified UART module.\n* @param pData Pointer to data buffer (u8 or u16 data elements).\n* @param Size Amount of data elements (u8 or u16) to be sent\n* @param Timeout Timeout duration\n* @retval HAL status\n*&#x2F;\nHAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData,\nuint16_t Size, uint32_t Timeout)\n\n\n\n\n&#x2F;**\n* @brief Sends an amount of data in non blocking mode.\n* @note When UART parity is not enabled (PCE &#x3D; 0), and Word Length is\nconfigured to 9 bits (M1-M0 &#x3D; 01),\n* the sent data is handled as a set of u16. In this case, Size must\nindicate the number\n* of u16 provided through pData.\n* @param huart Pointer to a UART_HandleTypeDef structure that contains\n* the configuration information for the specified UART module.\n* @param pData Pointer to data buffer (u8 or u16 data elements).\n* @param Size Amount of data elements (u8 or u16) to be sent\n* @retval HAL status\n*&#x2F;\nHAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t\n*pData, uint16_t Size)\n\n&#x2F;**\n* @brief Sends an amount of data in DMA mode.\n* @note When UART parity is not enabled (PCE &#x3D; 0), and Word Length is\nconfigured to 9 bits (M1-M0 &#x3D; 01),\n* the sent data is handled as a set of u16. In this case, Size must\nindicate the number\n* of u16 provided through pData.\n* @param huart Pointer to a UART_HandleTypeDef structure that contains\n* the configuration information for the specified UART module.\n* @param pData Pointer to data buffer (u8 or u16 data elements).\n* @param Size Amount of data elements (u8 or u16) to be sent\n* @retval HAL status\n*&#x2F;\nHAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t\n*pData, uint16_t Size)\n\n\n中断void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart);\nvoid HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart);\n\n\n我写的首先使能串口接收HAL_UART_Receive_IT(&amp;huart6,rxDatabuffer,sizeof(rxDatabuffer)); &#x2F;&#x2F; 触发接受后，hal库会一只去等，直到他接受到这个数据，然后进入中断回调函数\n\n然后编写按键中断&#x2F;&#x2F;按键中断\nvoid HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)\n&#123;\n    if(GPIO_Pin &#x3D;&#x3D; GPIO_PIN_0)\n    &#123;\n        uint32_t temp&#x3D;HAL_GetTick();\n\n        *((uint32_t *)txDatabuffer)&#x3D;temp; &#x2F;&#x2F;强制类型转换，把强制转换位uint32位的指针，前面再加一个*进行。。\n        while(huart1.gState !&#x3D;HAL_UART_STATE_READY);&#x2F;&#x2F; 防止还没发送完成串口被占用的时候继续发送数据\n        HAL_UART_Transmit_IT(&amp;huart1,txDatabuffer,sizeof(txDatabuffer)); &#x2F;&#x2F;串口的发送\n\n    &#125;\n&#125;\n\n接着编写串口接受完成中断void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)\n&#123;\n    HAL_GPIO_TogglePin(GPIOH,GPIO_PIN_10);\n    HAL_GPIO_TogglePin(GPIOH,GPIO_PIN_11);\n    HAL_GPIO_TogglePin(GPIOH,GPIO_PIN_12);\n    if(huart&#x3D;&#x3D;&amp;huart6)\n    &#123;\n        rxdata&#x3D;*((uint32_t*)rxDatabuffer);\n        HAL_UART_Receive_IT(&amp;huart6,rxDatabuffer,sizeof(rxDatabuffer)); &#x2F;&#x2F;因为触发中断后就会没有，所以还要再次触发一次中断函数\n    &#125;\n&#125;\n\n值得注意的是这个指针的强制类型转换很妙\n接线部分\n编程环境clion+cubeMX+cubemonitor\n时钟树\nSTM32的所有外设都是可以配置时钟的\n大部分外设挂载在APB总线上，它们的时钟频率等于总线频率\n部分外设可以单独设置时钟频率\n\n\n因为只有uart1和6是挂载在APB2上的，所以他们的波特率可以设得很高，而挂载在APB1的不行\n","slug":"uart学习","date":"2022-10-28T07:49:26.000Z","categories_index":"","tags_index":"嵌入式学习","author_index":"Shockley"},{"id":"bd2189ae81127890cb8b79118f0d3213","title":"sort 算法","content":"Swap交换函数void swap(int &amp;a,int &amp;b)\n&#123;\n\tint temp&#x3D;a;\n\ta&#x3D;b;\n\tb&#x3D;temp;\n&#125;\n\nvoid swap(int &amp;a,int &amp;b) 为什么要加&amp;符号？？\n参数里的&amp;表示引用型参数，在一般的参数传递的时候，形参是实参的副本，也就是说形参和实参在内存中的位置不同，用了引用型参数后，形参和实参在内存中的位置是一样的。**&amp; 这里表示引用，说明需要传递变量给这个函数，函数中可以对参数的值进行修改如果没有 &amp;，修改的就是函数体中的临时变量。**\n冒泡排序void bubble_sort(int* arr,int len)\n&#123;\n\tfor(int i&#x3D;0;i&lt;len-1;i++)\n\t&#123;\n\t\tfor(int k&#x3D;0;k&lt;len-1-i;k++)\n\t\t&#123;\n\t\t\tif(arr[k]&gt;arr[k+1]) &#x2F;&#x2F;表示从小到大排\n\t\t\t&#123;\n\t\t\t\tswap(arr[k],arr[k+1]);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n冒泡排序的时间复杂度为O（n^2）\n插入排序insertion sort 每次从未排序中取出一个元素插入到已排序序列中，不断重复直至所有元素均被移到排序序列\n\n\nvoid insertion_sort (int arr[], int len)\n&#123;\n\tint j,key;\n\tfor(int i&#x3D;1;i&lt;len;i++)\n\t&#123;\n\t\tkey&#x3D;arr[i];\n\t\tj&#x3D;i-1;\n\t\twhile(j&gt;&#x3D;0 &amp;&amp; (arr[j]&gt;key))\n\t\t&#123;\n\t\t\tarr[j+1]&#x3D;arr[j]; &#x2F;&#x2F;移位，留出插入空格\n\t\t\tj--;\n\t\t&#125;\n\t\tarr[j+1]&#x3D;key; &#x2F;&#x2F;把新元素插入到空格中，+1是因为*\n\t&#125;\n&#125;\n\n\nwhile中j要大于0原因是处理临界条件，如果key比较到第一个都不比它大的话就要插在第一个前面了，第一个移到后面\narr[j+1]是因为如果当j&#x3D;0时进入循环j就等于-1，然后最后赋值要把j加一才行\n第一层for循环是为了选择要插入的数\n第二层while是为了判断插入到哪里，并且移位\n\n归并排序归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。\n作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：\n\n自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；\n自下而上的迭代；\n\n算法步骤\nvoid merge(int* arr,int left ,int middle,int right)\n&#123;\n\tint i&#x3D;left;\n\tint j&#x3D;middle;\n\tint * temp&#x3D;(int *)malloc((right-left)*4);\n\tint index&#x3D;0;\n\twhile(i&lt;middle &amp;&amp; j&lt;right)\n\t\ttemp[index++]&#x3D;arr[i]&lt;arr[j]?arr[i++]:arr[j++];\n\twhile(i&lt;middle)\n\t\ttemp[index++]&#x3D;arr[i++];\n\twhile(j&lt;right)\n\t\ttemp[index++]&#x3D;arr[j++];\n\tfor(int i&#x3D;0;i&lt;index;i++)\n\t\tarr[left+i]&#x3D;temp[i];\n\tfree(temp);\n&#125;\nvoid merge_sort(int* arr,int left ,int right)\n&#123;\n\tif(right-left&lt;&#x3D;1) return;\n\tint middle&#x3D;(left+right)&gt;&gt;1; \n\tmerge_sort(arr,left,middle);\n\tmerge_sort(arr,middle,right);\n\tmerge(arr,left,middle,right);\n\t\n&#125;\n\n递归而言，首先肯定 要给出递归结束条件(right-left&lt;&#x3D;1),，递归的结束条件一定是：原最小子问题的解！！！而这里，当递归到最后一步时候，子数组只剩一下一个元素，而这个元素本身就是有序的，所以直接return即可（在其他问题中没准需要你给出最小子问题的解）\n递归函数和普通函数本质是一致的，并无本质区别，当发生自己调用自己的时候，你完全可以认为，它调用了一个其他函数，只是这个函数好像和自己长得一模一样，俗称双胞胎。并且和普通调用一样，每个调用都会生成一个独立的栈空间，因此，mid值并不是只有一个mid,而是在每个调用体里都有一个mid只存在自己的栈空间。\n因此，这里说明关于递归调用的两点：\n\n递归调用和普通函数调用并无区别，你可以把递归调用想成调用了一个和自己长得一样的其他函数；\n既然是函数调用，栈空间就是独立的，哪怕它是递归调用，也是如此；\n\n","slug":"sort","date":"2022-10-28T02:38:18.000Z","categories_index":"","tags_index":"ACM新手课堂练习","author_index":"Shockley"},{"id":"ba06baf3033674352e99290bfc5eedc6","title":"python 类学习笔记","content":"_ _init _ _创建classclass Dog:\n    def __init__(self,name,breed,age):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\na_dog&#x3D;Dog(&quot;abc&quot;,&quot;hound&quot;,3)\nprint(a_dog.age,a_dog.breed,a_dog.name)\n\n在类中定义函数class Dog:\n    def __init__(self,name,breed,age):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\n    def age_promote(self):\n        self.age+&#x3D;1\na_dog&#x3D;Dog(&quot;abc&quot;,&quot;hound&quot;,3)\nprint(a_dog.age,a_dog.breed,a_dog.name)\na_dog.age_promote()\nprint(a_dog.age)\n\n_ _str _ _def __str__(self):\n    &quot;&quot;&quot;返回一个对象的描述信息&quot;&quot;&quot;\n    # print(num)\n    return &quot;名字是:%s , 年龄是:%d&quot; % (self.name, self.age)\n\n变长参数列表语法\ndef function_name(fixed_arg,*args):\n    statements\n\narg可以是元组或列表\n*的意思是变长参数列表，即参数可能不确定\neg1：\nclass Dog:\n    def __init__(self,name,breed,age,*arg):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\n        self.list&#x3D;arg\n    def age_promote(self):\n        self.age+&#x3D;1\n    def print_arg(self):\n        for i in self.list:\n            print(i)\na_dog&#x3D;Dog(&quot;abc&quot;,&quot;hound&quot;,3,1,2,3)\na_dog.print_arg()\n\n输出1 2 3\neg2：\nclass Dog:\n    def __init__(self,name,breed,age,*arg):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\n        self.list&#x3D;arg\n    def age_promote(self):\n        self.age+&#x3D;1\n    def print_arg(self):\n        for i in self.list:\n            print(i)\na_dog&#x3D;Dog(&quot;abc&quot;,&quot;hound&quot;,3,[1,2,3])\na_dog.print_arg()\n\n输出[1,2,3]\neg3：\nclass Dog:\n    def __init__(self,name,breed,age,*arg):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\n        self.list&#x3D;arg\n    def age_promote(self):\n        self.age+&#x3D;1\n    def print_arg(self):\n        for i in self.list:\n            print(i)\na_dog&#x3D;Dog(&quot;abc&quot;,&quot;hound&quot;,3,*[1,2,3])\na_dog.print_arg()\n\n输出1 2 3（同eg1）\n继承一个类继承另一个类时，继承者是子类，被继承者是父类\nclass class_name(base_class):\n    class_definition\n\neg1:\nclass Dog:\n    def __init__(self,name,breed,age,*arg):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\n        self.list&#x3D;arg\n    def age_promote(self):\n        self.age+&#x3D;1\n    def print_arg(self):\n        for i in self.list:\n            print(i)\nclass cat(Dog):\n    def play(self):\n        s&#x3D;&#39;&#39;\n        while not s or s[0] in &#39;Nn&#39;:\n            print(self.name,&#39;fetches the balls!&#39;)\n            s&#x3D;input(&#39;wanna play again？(Y&#x2F;N)&#39;)\nclass puppy(cat):\n    def __init__(self,name,breed,age,sitdown):\n        cat.__init__(self,name,breed,age)\n        self.sitdown&#x3D;0\n    def sit(self):\n        if (self.sitdown&#x3D;&#x3D;0):\n            print(&quot;I am sitting down!&quot;)\n            self.sitdown&#x3D;1\n        else:\n            print(&quot;i am stand up&quot;)\n            self.sitdown&#x3D;0\na_dog&#x3D;Dog(&quot;abc&quot;,&quot;hound&quot;,3,*[1,2,3])\na_dog.print_arg()\npu&#x3D;puppy(&quot;abc&quot;,&quot;hound&quot;,3,0)\npu.sit()\npu.sit()\na_cat&#x3D;cat(&quot;abc&quot;,&quot;hound&quot;,3,*[1,2,3])\na_cat.play()\n\ncat 和puppy就是dog的子类\n在python中都有子类自动继承超类的方法，继承可以是直接的也可以是间接的，在这里puppy直接继承了cat类的所有方法，还继承了祖父类dog的所有属性\n子类继承了父类的所有方法，其中包括__init__ ，因此不是在所有时候都要重新编写__init__方法\n但也可以像上面puppy类这么写\n类变量和类方法类变量是由同一个类的所有成员共享的变量\neg1:\nclass Dog:\n    num_dogs&#x3D;0;\n    def __init__(self,name,breed,age):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\n        Dog.num_dogs+&#x3D;1\na_dog&#x3D;Dog(&quot;first_dog&quot;,&#39;ww&#39;,3)\nprint(&quot;dog_num: &quot;,Dog.num_dogs)\nanother_dog&#x3D;Dog(&quot;second_dog&quot;,&quot;ee&quot;,3)\nprint(&quot;Now_dog_num :&quot;,Dog.num_dogs)\n\n输出\ndog_num:  1\nNow_dog_num : 2\n\n实例变量在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的\nclass Address:\n    detail &#x3D; &quot;guangzhou&quot;\n    post_code &#x3D; &quot;510660&quot;\n    def info(self):\n        #尝试直接访问类变量\n        #print(detail) #报错\n\n        #通过类类访问类变量\n        print(Address.detail)\n        print(Address.post_code)\n\n#通过类来访问Address 类的类变量\nprint(Address.detail)\naddr &#x3D; Address()\naddr.info()\n#修改Address类的类变量\nAddress.detail &#x3D; &quot;fushan&quot;\n\nAddress.post_code &#x3D; &quot;460110&quot;\naddr.info()\n\n","slug":"Python类","date":"2022-10-27T13:17:47.000Z","categories_index":"","tags_index":"","author_index":"Shockley"},{"id":"bf4eea2954747cade91d710bb8265d76","title":"结构体 共用体","content":"typedef 用于创建已定义的数据类型的别名\n共用体 与结构体类似，但是其中的成员公用一个储存空间\n位运算符 用于处理整数中的数位\n位域 结构体的整形或无符号型成员变量，实现数据的压缩存储\n枚举 用标识符表示的一组整形变量\n结构体（aggregate）结构体可以包含不同数据类型的变量，将指针与结构体联合使用，可以实现更复杂的数据结构，如：链表，队列，堆栈和树\nfor example\nstruct employee&#123;\n\tchar firstname[20];\n\tchar lastname[20];\n\tunsigned int age;\n\tchar gender;\n\tdouble hourlySaraly;\n&#125;;\n\n结构体的定义关键字 struct\n结构体的自引用结构体不能包含他的自身类型，但是指向同一个结构体的指针却可以出现在结构体的定义中\n称为自引用结构体，可构成链式结构\nstruct employee2&#123;\n\tchar firstname[20];\n\tchar lastname[20];\n\tunsigned int age;\n\tchar gender;\n\tdouble hourlySaraly;\n&#x2F;&#x2F;\tstruct employee2 teamleader; error\n\tstruct employee2 *teamleader; &#x2F;&#x2F;pointer\n&#125;;\n\n定义结构体的类型变量结构体的定义并不占用内存中的任何空间，它只是创建了一种新的可以用来定义变量的数据类型。\n下面是定义结构体变量的两种方式\nstruct card&#123;\n\tchar *face;\n\tchar *suit;\n&#125;;\nstruct card aCard ,deck[52],*cardPtr;\n\nstruct card&#123;\n\tchar *face;\n\tchar *suit;\n&#125;aCard ,deck[52],*cardPtr;\n\n执行完上面语句后，系统才为一个类型为struct card 的变量申请aCard、数组deck中的52个struct card和一个未初始化的指向struct card 类型的指针申请空间\n结构体标记名结构体标记名可以省略，但是省略时，结构体类型变量的声明就只能和结构体定义同时进行\n结构体初始化与数组一样，可以采用初始值列表来初始化结构体\nStructures can be initialized using initializer lists as with arrays. To initialize a structure, follow the variable name in the definition with an equals sign and a brace-enclosed, comma-separated list of initializers. For example, the declaration.\nstruct card aCard &#x3D; &#123; &quot;Three&quot;, &quot;Hearts&quot; &#125;;\n\n用.和 -&gt;访问结构体成员有两种运算符来访问结构体的成员：\n结构体成员运算符  structure member operator   ( . )\n结构体指针运算符 structure pointer operator -&gt;\n例如：\nprintf(&quot;%s&quot;, aCard.suit); &#x2F;&#x2F; displays Hearts\n\n假设cardPtr是struct card类型的指针并且指向acard\n则有：\nprintf(&quot;%s&quot;, cardPtr-&gt;suit); &#x2F;&#x2F; displays Hearts\n\nattention :The expression cardPtr-&gt;suit is equivalent to **(cardPtr).suit*\naCard.face&#x3D;&quot;ACE&quot;;\naCard.suit&#x3D;&quot;Spades&quot;;\ncardPtr&#x3D;&amp;aCard;\nprintf(&quot;%s%s%s&quot;,aCard.face,cardPtr-&gt;face,(*cardPtr).face);\n\n在函数中使用结构体\n传递结构体的个别成员\nWhen structures or individual structure members are passed to a function, they’re passed by value. Therefore, the members of a caller’s structure cannot be modified by the called function\n\n传递整个结构体\n\n传递指向结构体的指针\n\n\ntypedef 的使用typedef struct card Card;\n\nCard can now be used to declare variables of type struct card. The declaration\nCard deck[52];\ndeclares an array of 52 Card structures.\n\n\n\n\n\n\n\n\n\nCreating a new name with typedef does not create a new type;typedef simply creates a new type name, which may be used as an alias for an existing type name.\n位运算符\n","slug":"结构体 共用体 位操作和枚举类型","date":"2022-10-27T13:17:47.000Z","categories_index":"","tags_index":"","author_index":"Shockley"},{"id":"61e647d1d27f6d8af1fd2619625e8201","title":"数组学习","content":"创建一维vectorvector&lt;int&gt; nums;&#x2F;&#x2F;不指定长度\nvector&lt;int&gt; nums(n); &#x2F;&#x2F; 指定长度为n \n\n添加元素nums.push_back(1);&#x2F;&#x2F;直接从数组末端添加\nnums[i] &#x3D; 1;&#x2F;&#x2F;直接赋值给第i个位置\n\n删除元素nums.resize(nums.size-i); &#x2F;&#x2F;直接将数组长度减小，某种方式上删掉了后面i个\nnums.pop_back();&#x2F;&#x2F;删掉最后一个元素\n\n遍历数组for(int i &#x3D; 0; i &lt; nums.size(); i++)&#123;\n    cout&lt;&lt;nums[i]&lt;&lt;endl;\n&#125;\n\n创建二维动态数组vector&lt;vector &lt;int&gt; &gt; nums(m ,vector&lt;int&gt;(n));    &#x2F;&#x2F;m*n的二维vector\n\n","slug":"数组学习","date":"2022-10-27T13:17:47.000Z","categories_index":"","tags_index":"","author_index":"Shockley"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\n编译hexo cl &amp;&amp; hexo g\n\nuploadhexo d\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-10-27T09:56:39.080Z","categories_index":"","tags_index":"","author_index":"Shockley"}]