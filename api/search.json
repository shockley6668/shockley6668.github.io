[{"id":"67338f19243fed8106d0d71a5166f950","title":"ros基础笔记","content":"ros 基础小记创建工作空间初始化工作空间\ncatkin_init_workspace\n\n编译工作空间\ncatkin_make\n\n设置环境变量\nsource devel&#x2F;setup.bash\n\n设置环境变量，并且不用每次都source\necho &quot;source&#x2F;WORKSPACE&#x2F;deve&#x2F;setup.bash&quot;&gt;&gt;~&#x2F;.bashrc\n\n创建功能包创建功能包\ncatkin_creak_pkg package_name depend1 depend2 depend3\n\n例如\ncatkin_create_pkg learning_communication std_msgs rospy roscpp\n\n创建发布者&#x2F;&#x2F; ROS节点初始化\nros::init(argc, argv, &quot;talker&quot;);\n\n&#x2F;&#x2F; 创建节点句柄\nros::NodeHandle n;\n\n&#x2F;&#x2F; 创建一个Publisher\nros::Publisher chatter_pub &#x3D; n.advertise&lt;std_msgs::String&gt;(&quot;chatter&quot;, 1000);\n\n创建订阅者&#x2F;&#x2F; 接收到订阅信号后，进入消息回调函数\nvoid chatterCallback(const std_msgs::String::ConstPtr&amp; msg)\n&#123;\n    &#x2F;&#x2F; 将接收到的消息打印出来\n    ROS_INFO(&quot;I heard: [%s]&quot;, msg-&gt;data.c_str());\n&#125;\n\nvoid main(int argc, char** argv)\n&#123;\n    &#x2F;&#x2F; 初始化ROS节点\n    ros::init(argc, argv, &quot;talker&quot;);\n    \n    &#x2F;&#x2F; 创建节点句柄\n    ros::NodeHandle n;\n    \n    &#x2F;&#x2F; 创建一个Subscriber\n    ros::Subscriber sub &#x3D; n.subsricbe(&quot;chatter&quot;, 1000, chatterCallback);\n    \n    &#x2F;&#x2F; 循环等待回调函数\n    ros::spin();\n    \n    return 0;\n&#125;\n\n自定义话题消息增加smg文件ROS中提供了一系列不同消息类型的功能包，如std_msgs、geometry_msgs等，很多情况下需，要针对自己的机器人应用设计特定的消息类型，以下列msg文件为例，定义了描述一个个人信息的消息类型\nstring name\nuint8 sex \nuint8 age\nuint8 unknown&#x3D;0\nuint8 male&#x3D;1\nunit8 female&#x3D;2\n\n修改CmakeList.txt","slug":"ros基础笔记","date":"2022-12-11T14:49:22.000Z","categories_index":"","tags_index":"","author_index":"Shockley"},{"id":"563aa1fc6f17a3a1184aeccab51ff935","title":"C语言oj心得_扫雪挑战","content":"扫雪挑战题目描述冬天到啦，住在南方城市的你可能从没见过下雪，但是住在北方城市的小明可犯了愁，他的家门口的街道堆满了雪！\n小明想要清理掉这些积雪，可是他一个人的力量不足以解决，于是他叫来了Q个工人帮忙\n但是这些工人有强迫症，他们只会清理从起点m到终点n的道路上的积雪（m，n均为整数，且m与n均会被清理）\n那么当经历了Q个工人清理积雪之后，还剩多长的道路上有积雪？\n你可以认为街道的长度从1开始\n其中1&lt;&#x3D;m&lt;&#x3D;n&lt;&#x3D;1000000\n输入街道的长度d\n工人的数目Q\n接下来有Q列，每一列输入一个工人清理的起点m与终点n\n输出剩下的没有被清理掉的积雪的长度\n输入样例\n1000\n3\n1 100\n200 300\n250 350\n\n输出样例\n749\n\n解题想法首先先定义一个结构体数组储存每个工人的起点和中点，接着对输入的每个工人的起点进行冒泡排序。因为是按照起点进行的排序的，所以必然会造成一个问题，就是下面第四点，如果上一个工人扫路的终点比上上个工人的起点还短，那么累计扫地的路段就是应该是end减去最长哪个last end，所以就要分别考虑各种情况，如下\n\n#include&lt;stdio.h&gt;\nint d,q;\ntypedef struct &#123;\n\tint end;\n\tint begin;\n&#125;eb;\neb gon[1000];\n\nint main()\n&#123;\n\tscanf(&quot;%d&quot;,&amp;d);\n\tscanf(&quot;%d&quot;,&amp;q);\n\tfor(int i&#x3D;0;i&lt;q;i++)\n\t&#123;\t\n\t\tscanf(&quot;%d%d&quot;,&amp;gon[i].begin,&amp;gon[i].end);\n\t&#125;\n\tfor(int i&#x3D;0;i&lt;q-1;i++)\n\t&#123;\n\t\tfor(int j&#x3D;0;j&lt;q-i-1;j++)\n\t\t&#123;\n\t\t\tif(gon[j].begin&gt;gon[j+1].begin)\n\t\t\t&#123;\n\t\t\t\teb temp;\n\t\t\t\ttemp&#x3D;gon[j];\n\t\t\t\tgon[j]&#x3D;gon[j+1];\n\t\t\t\tgon[j+1]&#x3D;temp;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tint ans&#x3D;gon[0].end-gon[0].begin+1;\n\tfor(int i&#x3D;1;i&lt;q;i++)\n\t&#123;\n\t\tif(gon[i-1].end&gt;gon[i].begin &amp;&amp; gon[i].end&gt;gon[i-1].end)\n\t\t\tans+&#x3D;gon[i].end-gon[i-1].end;\n\t\telse if(gon[i-1].end&lt;gon[i].begin)\n\t\t\tans+&#x3D;gon[i].end-gon[i].begin+1;\n\t\telse if(gon[i-1].end&#x3D;&#x3D;gon[i].begin)\n\t\t\tans+&#x3D;gon[i].end-gon[i].begin;\n\t\telse if (gon[i].end&lt;gon[i-1].end)\n\t\t\tgon[i].end&#x3D;gon[i-1].end; &#x2F;&#x2F;当end小于last end时，对last end进行赋值就能解决这个问题\n\t&#125;\n\tprintf(&quot;%d&quot;,d-ans);\n\treturn 0;\n&#125;\n","slug":"C语言oj心得","date":"2022-11-24T12:35:43.000Z","categories_index":"","tags_index":"","author_index":"Shockley"},{"id":"a28f4f35d46de8d7918b8b2e0cb657d2","title":"步进电机驱动——DRV8825","content":"步进电机驱动模块 DRV8825使用笔记步进电机工作原理步进电机使用带齿的轮和电磁铁来使论一次一步旋转\n\nDRV8825步进电机驱动器芯片\nm0 m1 m2 是微步引脚，简单来说，就是通过电平的高低控制步长\n\n\n\nM0\nM1\nM2\n微步分辨率\n\n\n\n低\n低\n低\n全步\n\n\n高\n低\n低\n半步\n\n\n低\n高\n低\n1&#x2F;4步\n\n\n高\n高\n低\n1&#x2F;8步\n\n\n低\n低\n高\n1&#x2F;16步\n\n\n高\n低\n高\n1&#x2F;32步\n\n\n低\n高\n高\n1&#x2F;32步\n\n\n高\n高\n高\n1&#x2F;32步\n\n\nstep引脚是控制电机的微步，每次检测到一个上升沿，就会按照你设置的微步来使电机运动，相应地，脉冲频率越快，电机旋转越快\nDIR引脚用于控制电机旋转方向，拉高顺时针，拉低逆时针转\nSLP&#x2F;SLEEP引脚为低电平有效输入。这意味着将该引脚拉至低电平可使驱动器进入睡眠模式，从而将功耗降至最低。特别是在不使用电动机以节省功率时，可以调用此方法。\n*vmot* 和 *GND MOT* 为电动机提供电源，该电源可以为8.2V至45V\nB2，B1，A1，A2 引脚为输出引脚\n","slug":"步进电机驱动——DRV8825","date":"2022-11-13T12:48:56.000Z","categories_index":"","tags_index":"","author_index":"Shockley"},{"id":"bc70f4e05aafed03ba0181aade8d3ac9","title":"贪心","content":"A - 电影节 OpenJ_Bailian - 4151大学生电影节在北大举办! 这天，在北大各地放了多部电影，给定每部电影的放映时间区间，区间重叠的电影不可能同时看（端点可以重合），问李雷最多可以看多少部电影。\nInput\n多组数据。每组数据开头是n(n&lt;&#x3D;100)，表示共n场电影。接下来n行，每行两个整数(0到1000之间)，表示一场电影的放映区间n&#x3D;0则数据结束\nOutput\n对每组数据输出最多能看几部电影\n按结束时间排序，维护一个“当前完成时间”nt，按顺序扫描，开始时间不早于nt的就安排上，更新nt为新安排的电影的结束时间。\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\nconst int maxn &#x3D; 111;\nstruct Node\n&#123;\n    int s, t;\n    bool operator&lt;(const Node&amp;that)const\n    &#123;\n        return t &lt; that.t;\n    &#125;\n&#125;;\nint n;\nNode mov[maxn];\nint main()\n&#123;\n    while(scanf(&quot;%d&quot;, &amp;n) !&#x3D; EOF &amp;&amp; n)\n    &#123;\n        for(int i &#x3D; 0; i &lt; n; i ++)\n            scanf(&quot;%d%d&quot;, &amp;mov[i].s, &amp;mov[i].t);\n        std::sort(mov, mov + n);\n        int ans &#x3D; 0, nt &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; i ++)\n            if(mov[i].s &gt;&#x3D; nt) ans ++, nt &#x3D; mov[i].t;\n        printf(&quot;%d\\n&quot;, ans);\n    &#125;\n    return 0;\n&#125;\n\nB - 数列分段 LibreOJ - 10006对于给定的一个长度为 NN 的正整数数列 A_iA**i，现要将其分成连续的若干段，并且每段和不超过 MM（可以等于 MM），问最少能将其分成多少段使得满足要求。\n输入格式\n第一行包含两个正整数 N,MN,M，表示了数列 A_iA**i 的长度与每段和的最大值；\n第二行包含 NN 个空格隔开的非负整数 A_iA**i。\n输出格式\n输出文件仅包含一个正整数，输出最少划分的段数。\n样例\n\n\n\nInputcopy\nOutputcopy\n\n\n\n5 6 4 2 4 5 1\n3\n\n\n每一段尽可能填满\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\nint n, m, a;\nint main()\n&#123;\n    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) !&#x3D; EOF)\n    &#123;\n        int now &#x3D; 0, cnt &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; i ++)\n        &#123;\n            scanf(&quot;%d&quot;, &amp;a);\n            if(now + a &lt;&#x3D; m) now +&#x3D; a;\n            else cnt ++, now &#x3D; a;\n        &#125;\n        printf(&quot;%d\\n&quot;, cnt + 1);\n    &#125;\n    return 0;\n&#125;\n\nC - 圣诞老人的礼物-Santa Clau’s Gifts OpenJ_Bailian - 4110圣诞节来临了，在城市A中圣诞老人准备分发糖果，现在有多箱不同的糖果，每箱糖果有自己的价值和重量，每箱糖果都可以拆分成任意散装组合带走。圣诞老人的驯鹿最多只能承受一定重量的糖果，请问圣诞老人最多能带走多大价值的糖果。\nInput\n第一行由两个部分组成，分别为糖果箱数正整数n(1 &lt;&#x3D; n &lt;&#x3D; 100)，驯鹿能承受的最大重量正整数w（0 &lt; w &lt; 10000），两个数用空格隔开。其余n行每行对应一箱糖果，由两部分组成，分别为一箱糖果的价值正整数v和重量正整数w，中间用空格隔开。\nOutput\n输出圣诞老人能带走的糖果的最大总价值，保留1位小数。输出为一行，以换行符结束。\nSample\n\n\n\nInputcopy\nOutputcopy\n\n\n\n4 15 100 4 412 8 266 7 591 2\n1193.0\n\n\n优先性价比高的\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\nconst int maxn &#x3D; 111;\nstruct Node\n&#123;\n    int v, w;\n    bool operator&lt;(const Node&amp;that)const\n    &#123;\n        return v * that.w &gt; that.v * w;\n    &#125;\n&#125;;\nNode s[maxn];\nint n, w;\nint main()\n&#123;\n    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;w) !&#x3D; EOF)\n    &#123;\n        for(int i &#x3D; 0; i &lt; n; i ++)\n            scanf(&quot;%d%d&quot;, &amp;s[i].v, &amp;s[i].w);\n        std::sort(s, s + n);\n        double ans &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n &amp;&amp; w; i ++)\n        &#123;\n            if(w &gt; s[i].w) ans +&#x3D; s[i].v, w -&#x3D; s[i].w;\n            else ans +&#x3D; 1.0 * w * s[i].v &#x2F; s[i].w, w &#x3D; 0;\n        &#125;\n        printf(&quot;%.1f\\n&quot;, ans);\n    &#125;\n    return 0;\n&#125;\n\nD - 种树 LibreOJ - 10001题目描述\n某条街被划为 nn 条路段，这 nn 条路段依次编号为 1…n。每个路段最多可以种一棵树。现在居民们给出了 hh 组建议，每组建议包含三个整数 b,e,tb,e,t，表示居民希望在路段 bb 到 ee 之间至少要种 tt 棵树。这些建议所给路段的区间可以交叉。请问：如果要满足所有居民的建议，至少要种多少棵树。\n输入格式\n第一行为 nn，表示路段数。\n第二行为 hh，表示建议数。\n下面 hh 行描述一条建议：b, e, tb,e,t，用一个空格分隔。\n输出格式\n输出只有一个数，为满足所有居民的建议，所需要种树的最少数量。\n样例\n\n\n\nInputcopy\nOutputcopy\n\n\n\n9 4 1 4 2 4 6 2 8 9 2 3 5 2\n5\n\n\n按区间右端点（e）排序，每个区间优先从后往前种树，因为靠后种树才更便于被后面的区间共用。\n这题的数据有坑——合法数据之后会输入一些无用数据。\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\nconst int maxn &#x3D; 3e5 + 10;\nconst int maxh &#x3D; 5e5 + 10;\nstruct Node\n&#123;\n    int b, e, t;\n    bool operator&lt;(const Node&amp;that)const\n    &#123;\n        return e &lt; that.e;\n    &#125;\n&#125;;\nNode s[maxh];\nbool vis[maxn];\nint n, h;\nint main()\n&#123;\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;h);\n    memset(vis, 0, sizeof(bool) * (n + 10));\n    for(int i &#x3D; 0; i &lt; h; i ++)\n        scanf(&quot;%d%d%d&quot;, &amp;s[i].b, &amp;s[i].e, &amp;s[i].t);\n    std::sort(s, s + h);\n    for(int i &#x3D; 0; i &lt; h; i ++)\n    &#123;\n        for(int j &#x3D; s[i].b; j &lt;&#x3D; s[i].e; j ++)\n            s[i].t -&#x3D; vis[j];\n        for(int j &#x3D; s[i].e; s[i].t &gt; 0; j --)\n            if(!vis[j]) vis[j] &#x3D; true, s[i].t --;\n    &#125;\n    int ans &#x3D; 0;\n    for(int i &#x3D; 0; i &lt;&#x3D; n; i ++)\n        ans +&#x3D; vis[i];\n    printf(&quot;%d\\n&quot;, ans);\n    return 0;\n&#125;\n\nE - 电池的寿命 OpenJ_Bailian - 3468小S新买了一个掌上游戏机，这个游戏机由两节5号电池供电。为了保证能够长时间玩游戏，他买了很多5号电池，这些电池的生产商不同，质量也有差异，因而使用寿命也有所不同，有的能使用5个小时，有的可能就只能使用3个小时。显然如果他只有两个电池一个能用5小时一个能用3小时，那么他只能玩3个小时的游戏，有一个电池剩下的电量无法使用，但是如果他有更多的电池，就可以更加充分地利用它们，比如他有三个电池分别能用3、3、5小时，他可以先使用两节能用3个小时的电池，使用半个小时后再把其中一个换成能使用5个小时的电池，两个半小时后再把剩下的一节电池换成刚才换下的电池（那个电池还能用2.5个小时），这样总共就可以使用5.5个小时，没有一点浪费。\n现在已知电池的数量和电池能够使用的时间，请你找一种方案使得使用时间尽可能的长。\nInput\n输入包含多组数据。每组数据包括两行，第一行是一个整数N (2 ≤ N ≤ 1000)，表示电池的数目，接下来一行是N个正整数表示电池能使用的时间。\nOutput\n对每组数据输出一行，表示电池能使用的时间，保留到小数点后1位。\nSample\n\n\n\nInputcopy\nOutputcopy\n\n\n\n2 3 5 3 3 3 5 \n3.0 5.5\n\n\n如果最大的电池大于其它电池总和，则答案为其它电池总和。\n否则一定有办法恰好消耗所有电量，则答案为总和一半。\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\nconst int maxn &#x3D; 1100;\nint n, cg[maxn], sum, mx;\nint main()\n&#123;\n    while(scanf(&quot;%d&quot;, &amp;n) !&#x3D; EOF)\n    &#123;\n        sum &#x3D; mx &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; i ++)\n            scanf(&quot;%d&quot;, &amp;cg[i]), sum +&#x3D; cg[i], mx &#x3D; std::max(mx, cg[i]);\n        if(mx &lt;&lt; 1 &gt; sum) printf(&quot;%.1f\\n&quot;, 1.0 * (sum - mx));\n        else printf(&quot;%.1f\\n&quot;, sum * 0.5);\n    &#125;\n    return 0;\n&#125;\n\nF - 最小新整数 OpenJ_Bailian - 4137给定一个十进制正整数n(0 &lt; n &lt; 1000000000)，每个数位上数字均不为0。n的位数为m。现在从m位中删除k位(0&lt;k &lt; m)，求生成的新整数最小为多少？例如: n &#x3D; 9128456, k &#x3D; 2, 则生成的新整数最小为12456\nInput\n第一行t, 表示有t组数据；接下来t行，每一行表示一组测试数据，每组测试数据包含两个数字n, k。\nOutput\nt行，每行一个数字，表示从n中删除k位后得到的最小整数。\nSample\n\n\n\nInputcopy\nOutputcopy\n\n\n\n2 9128456 2 1444 3 \n12456 1\n\n\n每次从高位向低位找第一个比相邻低位大的位置，比如 13245，第一次操作去掉 3，因为3比相邻低位的2大，去掉3收益最高。\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\nint n, k;\nint main()\n&#123;\n    int t;\n    for(scanf(&quot;%d&quot;, &amp;t); t --; )\n    &#123;\n        scanf(&quot;%d%d&quot;, &amp;n, &amp;k);\n        while(k --)\n        &#123;\n            int lst &#x3D; 1, l &#x3D; 1;\n            for(int i &#x3D; 10; i &lt; n; lst &#x3D; i, i *&#x3D; 10)\n                if(n &#x2F; i % 10 &gt; n &#x2F; lst % 10)\n                    l &#x3D; i;\n            n &#x3D; n &#x2F; l &#x2F; 10 * l + n % l;\n        &#125;\n        printf(&quot;%d\\n&quot;, n);\n    &#125;\n    return 0;\n&#125;\n\nG - 田忌赛马 OpenJ_Bailian - 4005C和S两位同学一起玩拼点游戏。有一堆白色卡牌和一堆蓝色卡牌，每张卡牌上写了一个整数点数。C随机抽取n张白色卡牌，S随机抽取n张蓝色卡牌，他们进行n回合拼点，每次两人各出一张卡牌，点数大者获得三颗巧克力，小者获得一颗巧克力，如果点数相同，每人各得二颗巧克力，使用过的卡牌不得重复使用。已知C和S取到的卡牌点数，请编程计算S最多和最少能得到多少颗巧克力。\nInput\n输入包含多组测试数据。每组测试数据的第一行是一个整数n(1&lt;&#x3D;n&lt;&#x3D;1000)，接下来一行是n个整数，表示C抽到的白色卡牌的点数，下一行也是n个整数，表示S抽到的蓝色卡牌的点数。输入的最后以一个0表示结束。\nOutput\n对每组数据，输出一行，内容是两个整数用空格格开，分别表示S最多和最少可获得的巧克力数。\nSample\n\n\n\nInputcopy\nOutputcopy\n\n\n\n3 92 83 71 95 87 74 2 20 20 20 20 2 20 19 22 18 0\n9 5 4 4 4 4\n\n\n贪心测策略：\n\n如果S当前最大的比C最大的大，直接比较\n如果S当前最大的比C最大的小，则用S当前最小的与C最大的比较\n如果S当前最大的与C最大的相等，则：\nS最小的比C最小的大，则S最小的先和C最小的比较\n否则，S最小的与C最大的比较\n\n\n\n总数减去反向田忌赛马即可求S最小结果\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\nconst int maxn &#x3D; 1100;\nint n, c[maxn], s[maxn];\nvoid Load(int x[])\n&#123;\n    for(int i &#x3D; 0; i &lt; n; i ++)\n        scanf(&quot;%d&quot;, &amp;x[i]);\n    std::sort(x, x + n);\n&#125;\nint TianJi(int x[], int y[])\n&#123;\n    int ret &#x3D; 0;\n    for(int il &#x3D; 0, ir &#x3D; n - 1, jl &#x3D; 0, jr &#x3D; n - 1; il &lt;&#x3D; ir;)\n    &#123;\n        if(x[ir] &gt; y[jr]) ret +&#x3D; 3, ir --, jr --;\n        else if(x[ir] &lt; y[jr]) ret +&#x3D; 1, il ++, jr --;\n        else\n        &#123;\n            if(x[il] &gt; y[jl]) ret +&#x3D; 3, il ++, jl ++;\n            else ret +&#x3D; (x[il] &#x3D;&#x3D; y[jr] ? 2 : 1), il ++, jr --;\n        &#125;\n    &#125;\n    return ret;\n&#125;\nint main()\n&#123;\n    while(scanf(&quot;%d&quot;, &amp;n) !&#x3D; EOF &amp;&amp; n)\n    &#123;\n        Load(c);\n        Load(s);\n        printf(&quot;%d %d\\n&quot;, TianJi(s, c), n * 4 - TianJi(c, s));\n\n    &#125;\n    return 0;\n&#125;\n\nH - 线段 LibreOJ - 10007题目描述\n数轴上有 nn 条线段，选取其中 kk 条线段使得这 kk 条线段两两没有重合部分，问 kk 最大为多少。\n输入格式\n第一行为一个正整数 nn；\n在接下来的 nn 行中，每行有 22 个数 a_i, b_ia**i,b**i，描述每条线段。\n输出格式\n输出一个整数，为 kk 的最大值。\n样例\n\n\n\nInputcopy\nOutputcopy\n\n\n\n3 0 2 2 4 1 3\n2\n\n\n电影节 OpenJ_Bailian - 4151 买一送一\n#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#include&lt;cstdlib&gt;\n#include&lt;algorithm&gt;\nconst int maxn &#x3D; 1e6 + 10;\nstruct Node\n&#123;\n    int s, t;\n    bool operator&lt;(const Node&amp;that)const\n    &#123;\n        return t &lt; that.t;\n    &#125;\n&#125;;\nint n;\nNode mov[maxn];\nint main()\n&#123;\n    while(scanf(&quot;%d&quot;, &amp;n) !&#x3D; EOF)\n    &#123;\n        for(int i &#x3D; 0; i &lt; n; i ++)\n            scanf(&quot;%d%d&quot;, &amp;mov[i].s, &amp;mov[i].t);\n        std::sort(mov, mov + n);\n        int ans &#x3D; 0, nt &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; i ++)\n            if(mov[i].s &gt;&#x3D; nt) ans ++, nt &#x3D; mov[i].t;\n        printf(&quot;%d\\n&quot;, ans);\n    &#125;\n    return 0;\n&#125;\n\nI - 智力大冲浪 LibreOJ - 10004题目描述\n小伟报名参加中央电视台的智力大冲浪节目。本次挑战赛吸引了众多参赛者，主持人为了表彰大家的勇气，先奖励每个参赛者 mm 元。先不要太高兴！因为这些钱还不一定都是你的？！接下来主持人宣布了比赛规则：\n首先，比赛时间分为 nn 个时段，它又给出了很多小游戏，每个小游戏都必须在规定期限 t_it**i 前完成。如果一个游戏没能在规定期限前完成，则要从奖励费 mm 元中扣去一部分钱 w_iw**i，w_iw**i 为自然数，不同的游戏扣去的钱是不一样的。当然，每个游戏本身都很简单，保证每个参赛者都能在一个时段内完成，而且都必须从整时段开始。主持人只是想考考每个参赛者如何安排组织自己做游戏的顺序。作为参赛者，小伟很想赢得冠军，当然更想赢取最多的钱！注意：比赛绝对不会让参赛者赔钱！\n输入格式\n输入共四行。\n第一行为 mm，表示一开始奖励给每位参赛者的钱；\n第二行为 nn，表示有 nn 个小游戏；\n第三行有 nn 个数，分别表示游戏 11 到 nn 的规定完成期限；\n第四行有 nn 个数，分别表示游戏 11 到 nn 不能在规定期限前完成的扣款数。\n输出格式\n输出仅一行，表示小伟能赢取最多的钱。\n样例\n\n\n\nInputcopy\nOutputcopy\n\n\n\n10000 7 4 2 4 3 1 4 6 70 60 50 40 30 20 10\n9950\n\n\nn个时间安排n个游戏，每个游戏有个截止时间。\n贪心策略： 既然每个时间都肯定会安排一个游戏，那么就看一看每个时间段安排哪个游戏。\n从第 n 个时间开始倒着枚举，看当前时间来得及做的（截止时间大于等于当前时间）的任务哪个最贵就安排上。\n枚举一轮之后，没安排上的那些任务就是一定会超期的，把这些加起来。\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\nconst int maxn &#x3D; 550;\nstruct Node\n&#123;\n    int t, w;\n&#125;;\nint n, m;\nNode g[maxn];\nint main()\n&#123;\n    while(scanf(&quot;%d%d&quot;, &amp;m, &amp;n) !&#x3D; EOF)\n    &#123;\n        for(int i &#x3D; 0; i &lt; n; i ++)\n            scanf(&quot;%d&quot;, &amp;g[i].t);\n        for(int i &#x3D; 0; i &lt; n; i ++) \n            scanf(&quot;%d&quot;, &amp;g[i].w);\n        for(int i &#x3D; n; i &gt;&#x3D; 1; i --)\n        &#123;\n            int mx &#x3D; -1, mxj;\n            for(int j &#x3D; 0; j &lt; n; j ++)\n            &#123;\n                if(g[j].t &gt;&#x3D; i &amp;&amp; g[j].w &gt; mx)\n                    mxj &#x3D; j, mx &#x3D; g[j].w;\n            &#125;\n            if(mx !&#x3D; -1) g[mxj].w &#x3D; -1;\n        &#125;\n        for(int i &#x3D; 0; i &lt; n; i ++)\n            if(g[i].w !&#x3D; -1) m -&#x3D; g[i].w;\n        printf(&quot;%d\\n&quot;, m);\n\n    &#125;\n    return 0;\n&#125;\n\nJ - Find Amir CodeForces - 804A大雄和他女朋友决定在国庆出游n个城市，城市被标记成1到n，每两个城市之间的路费为（i+j）mod（n+1），他们可以从任意一个城市出发，求游玩这n个城市需要的最少费用为多少\nInput\n第一行包含一个整数n (1 ≤ n ≤ 105) — 城市个数\nOutput\n打印单个整数：表示访问所有城市所需的最少花费。\nExamples\nInput\n2\n\nOutput\n0\n\nInput\n10\n\nOutput\n4\n\nNote\nIn the first example we can buy a ticket between the schools that costs .\n(1, n)、(2,n-1)捉对路费为0，n跳到2路费为1，计算路费为1的次数。\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\nint n;\nint main()\n&#123;\n    while(scanf(&quot;%d&quot;, &amp;n) !&#x3D; EOF)\n        printf(&quot;%d\\n&quot;, (n - 1) &gt;&gt; 1);\n    return 0;\n&#125;\n","slug":"贪心","date":"2022-11-10T01:38:30.000Z","categories_index":"","tags_index":"","author_index":"Shockley"},{"id":"99298ce049ccdc06bc2b056b9a20c2b4","title":"FreeRTOS_队列管理","content":"FreeRTOS队列管理全局变量和弊端在以往的教程中，我们创建的任务都是相对独立的，任务之间并没有互相通讯交换数据。有童鞋说当然可以通过定义一个全局变量来实现多任务之间共享数据呀。你有没有想过，如果有多个任务同时要对一个占多字节的全局变量进行修改，如果没有保护机制的话，当第一个任务赋值给全局变量赋值前几个字节后，如果此时调度器切换第二个任务执行给全局变量赋值另外的几个字节，那么这个全局变量的值就变得支离破碎毫无意义了。所以说使用全局变量其实是不太线程安全的，一种解决这个问题的方案就是采用队列。\n队列提供了一种任务间或者任务和中断间的通讯机制。\n\na图是采用进程间共享内存的方式，b图是采用消息队列的方式。\n通过进程间共享内存的方式，进程之间能够更快地共用和交互数据；消息队列则是提供了一种更通用且稳定的交互数据的方式。\n数据存储通常采用先进先出队列（FIFO）\n\n队列有如下两种实现方式：\n\n*复制队列（Queue by copy）* 表示写入队列的数据每个字节都被完整复制到队列中了，也叫值传递\n*引用队列（Queue by reference）* 表示写入队列的是要写入数据的引用（或者说是一个指针指向所引用的数据）而并不是数据本身\n\nFreeRTOS采用是复制队列的实现方式\n多任务访问和阻塞任何任务都可以往队列中发送东西\n出队阻塞当任务尝试从一个队列中读取数据的时候，但是这个队列啊，不一定有数据，那么现在有三种选择：1.继续执行下面的程序2.等一会3，死等。选哪一个就是由阻塞时间决定的.0就是不阻塞，设置为portMAX_DELAY的话，任务就会一直进入阻塞态等待，直到收到数据为止。\n入队阻塞任务向队列里面发消息，和出队阻塞一样，当一个任务向队列发消息的话也可以设置阻塞时间，比如任务B向队列Q发消息，队列Q是满的，情况就和上面的一样了。\n常见队列操作方法下面将介绍创建和使用队列需要用到的几个函数\nQueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize )\n\nxQueueCreate（）是创建队列用到的函数。函数的返回值是QueueHandle_t具柄类型，表示的是对所创建队列的一个引用句柄。FreeRTOS从FreeRTOS的堆中指定一些内存空间给队列使用。如果堆中没有足够空间给队列使用的话函数的返回值会是NULL。\n这个函数本质上是一个宏，用来创建动态队列，最终会调用函数xQUEUEGenericStatic()\n\nuxQueueLength 队列包含数据的最大长度\nuxItemSize 每个数据占用的字节大小\n\nBaseType_t xQueueSend( QueueHandle_t xQueue, const void * pvItemToQueue,\nTickType_t xTicksToWait )\n\nxQueueSend（）函数用于将数据发送到队列（具体一点就是队列的尾部）。如果要在中断程序调用的话需要使用xQueueSendFromISR（）函数。\n\nxQueue 队列的具柄，来自于xQueueCreate（）的返回值\npvItemToQueue 所发送数据的引用，然后这些数据会被复制到队列中\nxTicksToWait 队列如果满时发送任务的阻塞时间（block time），上文已经介绍过，可以通过pdMS_TO_TICKS()把时间转换成节拍数。如果设置为portMAX_DELAY的话任务将永远等待下去（需要FreeRTOSConfig.h头文件中INCLUDE_vTaskSuspend参数设置为1）\n返回值 发送数据成功时返回pdPASS，失败时返回errQUEUE_FULL\n\n下面两个函数用于明确指定发送数据到队列的头部还是尾部。\nBaseType_t xQueueSendToFront( QueueHandle_t xQueue, const void * pvItemToQueue,\nTickType_t xTicksToWait )\nBaseType_t xQueueSendToBack( QueueHandle_t xQueue, const void * pvItemToQueue,\nTickType_t xTicksToWait )\n\nxQueueSend（）函数和xQueueSendToBack（）函数本质上是一样的。\nBaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer,\nTickType_t xTicksToWait )\n\n\n\nxQueue 队列的具柄，来自于xQueueCreate（）的返回值\npvBuffer 指向内存空间的一个引用，读取的数据会被复制到这片内存\nxTicksToWait 队列如果空时接送任务的阻塞时间（block time），上文已经介绍过，可以通过pdMS_TO_TICKS()把时间转换成节拍数。如果设置为portMAX_DELAY的话任务将永远等待下去（需要FreeRTOSConfig.h头文件中INCLUDE_vTaskSuspend参数设置为1）\n返回值 接收数据成功时返回pdPASS，失败时返回errQUEUE_EMPTY\n\nUBaseType_t uxQueueMessagesWaiting( QueueHandle_t xQueue )\n\nuxQueueMessagesWaiting（）函数用于获得队列中数据的数量\n队列结构体","slug":"FreeRTOS-队列管理","date":"2022-11-04T13:37:18.000Z","categories_index":"","tags_index":"嵌入式学习","author_index":"Shockley"},{"id":"137114166de934a4dd5b894c333fbc29","title":"排序题目","content":"Description 1冒泡排序是一种常见的排序算法，本题要求用冒泡排序算法对一组正整数进行从小到大排序.\n从小到大输出排序好的数，数之间用空格分开，行尾没有多余的空格.\nInput多组测试数据，每组数据第一行为 n 表示有n 个数。第二行为n个空格隔开的500内的正整数.\n1 ≤ n ≤ 100.\nOutput从小到大输出这些正整数，空格隔开，行末没有多余的空格\nSample Input5\n6 7 2 4 3\n4\n9 2 4 1\n\nSample Output2 3 4 6 7\n1 2 4 9\n\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\nint a[110], n;\nvoid Swap(int &amp;a, int &amp;b) &#x2F;&#x2F;把真实地址传进去\n&#123;\n    int tmp &#x3D; a;\n    a &#x3D; b;\n    b &#x3D; tmp;\n&#125;\nint main()\n&#123;\n    for(n &#x3D; 0; scanf(&quot;%d&quot;, &amp;a[n]) !&#x3D; EOF; n ++);\n    for(int i &#x3D; n - 1; i &gt;&#x3D; 0; i --)\n        for(int j &#x3D; 0; j &lt; i; j ++)\n            if(a[j] &gt; a[j + 1]) Swap(a[j], a[j + 1]);\n    for(int i &#x3D; 0; i &lt; n; i ++)\n        printf(&quot; %d&quot; + !i, a[i]);\n    printf(&quot;\\n&quot;);\n    return 0;\n&#125;\n\nDescription 2一个都不大于500的非负整数序列，取出其中的奇数进行排序输出。\nInput多组测试数据，每组数据第一行为 n 表示有n 个数. 第二行为n个空格隔开的int范围内的正整数.\n1 ≤ n ≤ 100.\nOutput从小到大输出提供数据的奇数，空格隔开，行末没有多余的空格.\nSample Input5\n6 7 2 4 3\n4\n9 2 4 1\n\nSample Output3 7\n1 9\n\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nint a[1110], n, m, x;\nint main()\n&#123;\n    while(scanf(&quot;%d&quot;, &amp;n) !&#x3D; EOF)\n    &#123;\n        for(m &#x3D; 0; n --;)\n        &#123;\n            scanf(&quot;%d&quot;, &amp;x);\n            if(x &amp; 1) a[m ++] &#x3D; x;\n        &#125;\n        std::sort(a, a + m);\n        for(int i &#x3D; 0; i &lt; m; i ++)\n            printf(&quot;,%d&quot; + !i, a[i]); &#x2F;&#x2F;字符串就是一个首地址，加一的话就是第二个字符的地址，逗号就没了\n        printf(&quot;\\n&quot;);\n    &#125;\n    return 0;\n&#125;\n\n","slug":"排序题目","date":"2022-10-30T13:21:16.000Z","categories_index":"","tags_index":"ACM新手课堂练习","author_index":"Shockley"},{"id":"f4b64ea2c88bb417cb737aa4fba9997c","title":"uart学习","content":"串口简介（Universal Synchronous&#x2F;Asynchronous Receiver&#x2F;Transmitter）\n通用异步收发传输器（没有时钟线），相对地，有时钟线就是同步通信\n\n具有TX和RX两根线\n\n可以将数据串行地发送给对方\n\n\n\n\n\n\n\n\n\n串口数据按照位依次发送，同时只有一条信号线用于发送\n大多数协议都是串行的\n\n波特率：每秒钟串口发送的位速率\n\n常用115200，就是11.25kb&#x2F;s\n\nTX接RX，RX接TX\n\n可以同时发送和接收（全双工）\n\n一个数据包由起始位，结束位，数据位，校验位组成\n\n发送每一位的时长由波特率决定，停止位可以是一到两个时钟\n\n串口空闲时保持高电平\n\n数据位可以是5到九位，最低位LSB先发送，最高位MSB后发送\n\n\nUSART 通信协议\n\n起始位：当未有数据发送时，数据线处于逻辑“1”状态；先发出一个逻辑“0”信号，表示开始传输字 符。\n数据位：紧接着起始位之后。数据位的个数可以是4、5、6、7、8等，构成一个字符。通常采用 ASCII码。从最低位开始传送，靠时钟定位。\n奇偶校验位：数据为加上这一位后，使得“1”的位数应为偶数（偶校验）或奇数（奇校验），以此 来校验资料传送的正确性。\n停止位：它是一个字符数据的结束标志。可以是1位、1.5位、2位的高电平。 由于数据是在传输线 上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备间出现了小小的不同步。因 此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟同步的机会。适用于停止位的位数越 多，不同时钟同步的容忍程度越大，但是数据传输率同时也越慢。\n空闲位或起始位：处于逻辑“1”状态，表示当前线路上没有资料传送，进入空闲状态。处于逻辑“0” 状态，表示开始传送下一数据段。\n\nSTM32串口工作原理发送数据被写入串口外设，然后按照波特率依次发送数据并添加起始位和停止位\n接收串口外设可配置位以波特率的8倍或16倍的频率采样RX引脚上的电瓶，然后自动分析提取\n串口外设中断\nFIFO 溢出错误\n\n线中止错误（line-break，即Rx 信号一直为0 的状态，包括校验位和停止位在内）\n\n奇偶校验错误\n\n帧错误（停止位不为1）\n\n接收超时（接收FIFO 已有数据但未满，而后续数据长时间不来）\n\n发送\n\n接收\n\n\n实验部分本实验主要完成通过按键触发中断从串口一发送然后串口六接受\n预备知识（USART API）接收&#x2F;**\n* @brief Receives an amount of data in blocking mode.\n* @note When UART parity is not enabled (PCE &#x3D; 0), and Word Length is\nconfigured to 9 bits (M1-M0 &#x3D; 01),\n* the received data is handled as a set of u16. In this case, Size\nmust indicate the number\n* of u16 available through pData.\n* @param huart Pointer to a UART_HandleTypeDef structure that contains\n* the configuration information for the specified UART module.\n* @param pData Pointer to data buffer (u8 or u16 data elements).\n* @param Size Amount of data elements (u8 or u16) to be received.\n* @param Timeout Timeout duration\n* @retval HAL status\n*&#x2F;\nHAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData,\nuint16_t Size, uint32_t Timeout)\n\n阻塞式接受，等到直到超时\n&#x2F;**\n* @brief Receives an amount of data in non blocking mode.\n* @note When UART parity is not enabled (PCE &#x3D; 0), and Word Length is\nconfigured to 9 bits (M1-M0 &#x3D; 01),\n* the received data is handled as a set of u16. In this case, Size\nmust indicate the number\n* of u16 available through pData.\n* @param huart Pointer to a UART_HandleTypeDef structure that contains\n* the configuration information for the specified UART module.\n* @param pData Pointer to data buffer (u8 or u16 data elements).\n* @param Size Amount of data elements (u8 or u16) to be received.\n* @retval HAL status\n*&#x2F;\nHAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)\n\n中断式接受\n&#x2F;**\n* @brief Receives an amount of data in DMA mode.\n* @note When UART parity is not enabled (PCE &#x3D; 0), and Word Length is\nconfigured to 9 bits (M1-M0 &#x3D; 01),\n* the received data is handled as a set of u16. In this case, Size\nmust indicate the number\n* of u16 available through pData.\n* @param huart Pointer to a UART_HandleTypeDef structure that contains\n* the configuration information for the specified UART module.\n* @param pData Pointer to data buffer (u8 or u16 data elements).\n* @param Size Amount of data elements (u8 or u16) to be received.\n* @note When the UART parity is enabled (PCE &#x3D; 1) the received data contains\nthe parity bit.\n* @retval HAL status\n*&#x2F;\nHAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t* pData, uint16_t Size)\n\n使用DMA中断进行接收\n发送&#x2F;**\n* @brief Sends an amount of data in blocking mode.\n* @note When UART parity is not enabled (PCE &#x3D; 0), and Word Length is\nconfigured to 9 bits (M1-M0 &#x3D; 01),\n* the sent data is handled as a set of u16. In this case, Size must\nindicate the number\n* of u16 provided through pData.\n* @param huart Pointer to a UART_HandleTypeDef structure that contains\n* the configuration information for the specified UART module.\n* @param pData Pointer to data buffer (u8 or u16 data elements).\n* @param Size Amount of data elements (u8 or u16) to be sent\n* @param Timeout Timeout duration\n* @retval HAL status\n*&#x2F;\nHAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData,\nuint16_t Size, uint32_t Timeout)\n\n\n\n\n&#x2F;**\n* @brief Sends an amount of data in non blocking mode.\n* @note When UART parity is not enabled (PCE &#x3D; 0), and Word Length is\nconfigured to 9 bits (M1-M0 &#x3D; 01),\n* the sent data is handled as a set of u16. In this case, Size must\nindicate the number\n* of u16 provided through pData.\n* @param huart Pointer to a UART_HandleTypeDef structure that contains\n* the configuration information for the specified UART module.\n* @param pData Pointer to data buffer (u8 or u16 data elements).\n* @param Size Amount of data elements (u8 or u16) to be sent\n* @retval HAL status\n*&#x2F;\nHAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t\n*pData, uint16_t Size)\n\n&#x2F;**\n* @brief Sends an amount of data in DMA mode.\n* @note When UART parity is not enabled (PCE &#x3D; 0), and Word Length is\nconfigured to 9 bits (M1-M0 &#x3D; 01),\n* the sent data is handled as a set of u16. In this case, Size must\nindicate the number\n* of u16 provided through pData.\n* @param huart Pointer to a UART_HandleTypeDef structure that contains\n* the configuration information for the specified UART module.\n* @param pData Pointer to data buffer (u8 or u16 data elements).\n* @param Size Amount of data elements (u8 or u16) to be sent\n* @retval HAL status\n*&#x2F;\nHAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t\n*pData, uint16_t Size)\n\n\n中断void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart);\nvoid HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart);\n\n\n我写的首先使能串口接收HAL_UART_Receive_IT(&amp;huart6,rxDatabuffer,sizeof(rxDatabuffer)); &#x2F;&#x2F; 触发接受后，hal库会一只去等，直到他接受到这个数据，然后进入中断回调函数\n\n然后编写按键中断&#x2F;&#x2F;按键中断\nvoid HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)\n&#123;\n    if(GPIO_Pin &#x3D;&#x3D; GPIO_PIN_0)\n    &#123;\n        uint32_t temp&#x3D;HAL_GetTick();\n\n        *((uint32_t *)txDatabuffer)&#x3D;temp; &#x2F;&#x2F;强制类型转换，把强制转换位uint32位的指针，前面再加一个*进行。。\n        while(huart1.gState !&#x3D;HAL_UART_STATE_READY);&#x2F;&#x2F; 防止还没发送完成串口被占用的时候继续发送数据\n        HAL_UART_Transmit_IT(&amp;huart1,txDatabuffer,sizeof(txDatabuffer)); &#x2F;&#x2F;串口的发送\n\n    &#125;\n&#125;\n\n接着编写串口接受完成中断void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)\n&#123;\n    HAL_GPIO_TogglePin(GPIOH,GPIO_PIN_10);\n    HAL_GPIO_TogglePin(GPIOH,GPIO_PIN_11);\n    HAL_GPIO_TogglePin(GPIOH,GPIO_PIN_12);\n    if(huart&#x3D;&#x3D;&amp;huart6)\n    &#123;\n        rxdata&#x3D;*((uint32_t*)rxDatabuffer);\n        HAL_UART_Receive_IT(&amp;huart6,rxDatabuffer,sizeof(rxDatabuffer)); &#x2F;&#x2F;因为触发中断后就会没有，所以还要再次触发一次中断函数\n    &#125;\n&#125;\n\n值得注意的是这个指针的强制类型转换很妙\n接线部分\n编程环境clion+cubeMX+cubemonitor\n时钟树\nSTM32的所有外设都是可以配置时钟的\n大部分外设挂载在APB总线上，它们的时钟频率等于总线频率\n部分外设可以单独设置时钟频率\n\n\n因为只有uart1和6是挂载在APB2上的，所以他们的波特率可以设得很高，而挂载在APB1的不行\n","slug":"uart学习","date":"2022-10-28T07:49:26.000Z","categories_index":"","tags_index":"嵌入式学习","author_index":"Shockley"},{"id":"bd2189ae81127890cb8b79118f0d3213","title":"sort 算法","content":"Swap交换函数void swap(int &amp;a,int &amp;b)\n&#123;\n\tint temp&#x3D;a;\n\ta&#x3D;b;\n\tb&#x3D;temp;\n&#125;\n\nvoid swap(int &amp;a,int &amp;b) 为什么要加&amp;符号？？\n参数里的&amp;表示引用型参数，在一般的参数传递的时候，形参是实参的副本，也就是说形参和实参在内存中的位置不同，用了引用型参数后，形参和实参在内存中的位置是一样的。**&amp; 这里表示引用，说明需要传递变量给这个函数，函数中可以对参数的值进行修改如果没有 &amp;，修改的就是函数体中的临时变量。**\n冒泡排序void bubble_sort(int* arr,int len)\n&#123;\n\tfor(int i&#x3D;0;i&lt;len-1;i++)\n\t&#123;\n\t\tfor(int k&#x3D;0;k&lt;len-1-i;k++)\n\t\t&#123;\n\t\t\tif(arr[k]&gt;arr[k+1]) &#x2F;&#x2F;表示从小到大排\n\t\t\t&#123;\n\t\t\t\tswap(arr[k],arr[k+1]);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n冒泡排序的时间复杂度为O（n^2）\n插入排序insertion sort 每次从未排序中取出一个元素插入到已排序序列中，不断重复直至所有元素均被移到排序序列\n\n\nvoid insertion_sort (int arr[], int len)\n&#123;\n\tint j,key;\n\tfor(int i&#x3D;1;i&lt;len;i++)\n\t&#123;\n\t\tkey&#x3D;arr[i];\n\t\tj&#x3D;i-1;\n\t\twhile(j&gt;&#x3D;0 &amp;&amp; (arr[j]&gt;key))\n\t\t&#123;\n\t\t\tarr[j+1]&#x3D;arr[j]; &#x2F;&#x2F;移位，留出插入空格\n\t\t\tj--;\n\t\t&#125;\n\t\tarr[j+1]&#x3D;key; &#x2F;&#x2F;把新元素插入到空格中，+1是因为*\n\t&#125;\n&#125;\n\n\nwhile中j要大于0原因是处理临界条件，如果key比较到第一个都不比它大的话就要插在第一个前面了，第一个移到后面\narr[j+1]是因为如果当j&#x3D;0时进入循环j就等于-1，然后最后赋值要把j加一才行\n第一层for循环是为了选择要插入的数\n第二层while是为了判断插入到哪里，并且移位\n\n归并排序归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。\n作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：\n\n自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；\n自下而上的迭代；\n\n算法步骤\nvoid merge(int* arr,int left ,int middle,int right)\n&#123;\n\tint i&#x3D;left;\n\tint j&#x3D;middle;\n\tint * temp&#x3D;(int *)malloc((right-left)*4);\n\tint index&#x3D;0;\n\twhile(i&lt;middle &amp;&amp; j&lt;right)\n\t\ttemp[index++]&#x3D;arr[i]&lt;arr[j]?arr[i++]:arr[j++];\n\twhile(i&lt;middle)\n\t\ttemp[index++]&#x3D;arr[i++];\n\twhile(j&lt;right)\n\t\ttemp[index++]&#x3D;arr[j++];\n\tfor(int i&#x3D;0;i&lt;index;i++)\n\t\tarr[left+i]&#x3D;temp[i];\n\tfree(temp);\n&#125;\nvoid merge_sort(int* arr,int left ,int right)\n&#123;\n\tif(right-left&lt;&#x3D;1) return;\n\tint middle&#x3D;(left+right)&gt;&gt;1; \n\tmerge_sort(arr,left,middle);\n\tmerge_sort(arr,middle,right);\n\tmerge(arr,left,middle,right);\n\t\n&#125;\n\n递归而言，首先肯定 要给出递归结束条件(right-left&lt;&#x3D;1),，递归的结束条件一定是：原最小子问题的解！！！而这里，当递归到最后一步时候，子数组只剩一下一个元素，而这个元素本身就是有序的，所以直接return即可（在其他问题中没准需要你给出最小子问题的解）\n递归函数和普通函数本质是一致的，并无本质区别，当发生自己调用自己的时候，你完全可以认为，它调用了一个其他函数，只是这个函数好像和自己长得一模一样，俗称双胞胎。并且和普通调用一样，每个调用都会生成一个独立的栈空间，因此，mid值并不是只有一个mid,而是在每个调用体里都有一个mid只存在自己的栈空间。\n因此，这里说明关于递归调用的两点：\n\n递归调用和普通函数调用并无区别，你可以把递归调用想成调用了一个和自己长得一样的其他函数；\n既然是函数调用，栈空间就是独立的，哪怕它是递归调用，也是如此；\n\nC++ std::sort()实际写代码时很少手撸排序算法，因为 STL 已经为我们提供了方便好用的库函数 std::sort() ，该函数定义在头文件  中。\n食用方法该函数的基本用法为：\nstd::sort(s, s+n);\n\n其中 s 为需要排序的数组， n 为需要排序的区间长度。该函数传入的参数为两个指针，用于指定排序的范围 [L, R)。例如对长度为 5 的数组进行排序：注意，如果数组从第 1 位开始保存数据，那么排序时也要相应的偏移 1 位：\nstd::sort(s+1, s+n+1);\n\n自定义排序顺序sort() 函数默认情况下是按从小到大的顺序排序的，如果我们想从大到小排序或者对结构体排序，就需要向 sort() 指定我们期望的排序规则\n使用标准库比较函数如果只是想简单地将数组从大到小排序，标准库自带的比较函数就可以满足需求。\n   #include      &#x2F;&#x2F; std::cout    #include    &#x2F;&#x2F; std::greater    #include     &#x2F;&#x2F; std::sort\nint main () &#123;\n  int numbers[]&#x3D;&#123;20,40,50,10,30&#125;;\n  std::sort (numbers, numbers+5, std::greater&lt;int&gt;());\n  for (int i&#x3D;0; i&lt;5; i++)\n    std::cout &lt;&lt; numbers[i] &lt;&lt; &#39; &#39;;\n  std::cout &lt;&lt; &#39;\\n&#39;;\n  return 0;\n&#125;\n自定义比较函数自定义排序顺序的一种方法是向 sort() 多传入一个比较函数作为参数。比较函数是返回值为（或可转化为） bool 类型的双参函数，它定义了元素之间的严格弱序关系，当参数 1 优先于参数 2 时返回true ，反之返回 false \n#include&lt;cstdlib&gt;\n#include &lt;algorithm&gt;    \nint n&#x3D;10;\nstruct node\n&#123;\n\tint price, weight, value; &#x2F;&#x2F;价格、重量、价值\n&#125;;\nbool cmp1(const node &amp;a, const node &amp;b) &#x2F;&#x2F;规则1，按价格从小到大排序\n&#123;\n\treturn a.price &lt; b.price;\n&#125;\nbool cmp2(const node &amp;a, const node &amp;b) &#x2F;&#x2F;规则2，按价值从大到小排序\n&#123;\n\treturn a.value &gt; b.value;\n&#125;\n&#x2F;&#x2F;规则3，多关键字排序\n&#x2F;&#x2F;先按价值从大到小排序\n&#x2F;&#x2F;如果价值相同则按价格从小到大排序\n&#x2F;&#x2F;如果价值、价格都相同，则按重量从小到大排序\nbool cmp3(const node &amp;a, const node &amp;b)\n&#123;\n\tif (a.value &#x3D;&#x3D; b.value &amp;&amp; a.price &#x3D;&#x3D; b.price) return a.weight &lt; b.weight;\n\tif (a.value &#x3D;&#x3D; b.value) return a.price &lt; b.price;\n\treturn a.value &gt; b.value;\n&#125;\nnode s[105];\nint main()\n&#123;\n\tstd::sort(s, s+n, cmp1); &#x2F;&#x2F;使用规则1排序\n\tstd::sort(s, s+n, cmp2); &#x2F;&#x2F;使用规则2排序\n\tstd::sort(s, s+n, cmp3);&#x2F;&#x2F;使用规则3排序\n\treturn 0;\n&#125;\n\n","slug":"sort","date":"2022-10-28T02:38:18.000Z","categories_index":"","tags_index":"ACM新手课堂练习","author_index":"Shockley"},{"id":"ba06baf3033674352e99290bfc5eedc6","title":"python 类学习笔记","content":"_ _init _ _创建classclass Dog:\n    def __init__(self,name,breed,age):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\na_dog&#x3D;Dog(&quot;abc&quot;,&quot;hound&quot;,3)\nprint(a_dog.age,a_dog.breed,a_dog.name)\n\n在类中定义函数class Dog:\n    def __init__(self,name,breed,age):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\n    def age_promote(self):\n        self.age+&#x3D;1\na_dog&#x3D;Dog(&quot;abc&quot;,&quot;hound&quot;,3)\nprint(a_dog.age,a_dog.breed,a_dog.name)\na_dog.age_promote()\nprint(a_dog.age)\n\n_ _str _ _def __str__(self):\n    &quot;&quot;&quot;返回一个对象的描述信息&quot;&quot;&quot;\n    # print(num)\n    return &quot;名字是:%s , 年龄是:%d&quot; % (self.name, self.age)\n\n变长参数列表语法\ndef function_name(fixed_arg,*args):\n    statements\n\narg可以是元组或列表\n*的意思是变长参数列表，即参数可能不确定\neg1：\nclass Dog:\n    def __init__(self,name,breed,age,*arg):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\n        self.list&#x3D;arg\n    def age_promote(self):\n        self.age+&#x3D;1\n    def print_arg(self):\n        for i in self.list:\n            print(i)\na_dog&#x3D;Dog(&quot;abc&quot;,&quot;hound&quot;,3,1,2,3)\na_dog.print_arg()\n\n输出1 2 3\neg2：\nclass Dog:\n    def __init__(self,name,breed,age,*arg):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\n        self.list&#x3D;arg\n    def age_promote(self):\n        self.age+&#x3D;1\n    def print_arg(self):\n        for i in self.list:\n            print(i)\na_dog&#x3D;Dog(&quot;abc&quot;,&quot;hound&quot;,3,[1,2,3])\na_dog.print_arg()\n\n输出[1,2,3]\neg3：\nclass Dog:\n    def __init__(self,name,breed,age,*arg):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\n        self.list&#x3D;arg\n    def age_promote(self):\n        self.age+&#x3D;1\n    def print_arg(self):\n        for i in self.list:\n            print(i)\na_dog&#x3D;Dog(&quot;abc&quot;,&quot;hound&quot;,3,*[1,2,3])\na_dog.print_arg()\n\n输出1 2 3（同eg1）\n继承一个类继承另一个类时，继承者是子类，被继承者是父类\nclass class_name(base_class):\n    class_definition\n\neg1:\nclass Dog:\n    def __init__(self,name,breed,age,*arg):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\n        self.list&#x3D;arg\n    def age_promote(self):\n        self.age+&#x3D;1\n    def print_arg(self):\n        for i in self.list:\n            print(i)\nclass cat(Dog):\n    def play(self):\n        s&#x3D;&#39;&#39;\n        while not s or s[0] in &#39;Nn&#39;:\n            print(self.name,&#39;fetches the balls!&#39;)\n            s&#x3D;input(&#39;wanna play again？(Y&#x2F;N)&#39;)\nclass puppy(cat):\n    def __init__(self,name,breed,age,sitdown):\n        cat.__init__(self,name,breed,age)\n        self.sitdown&#x3D;0\n    def sit(self):\n        if (self.sitdown&#x3D;&#x3D;0):\n            print(&quot;I am sitting down!&quot;)\n            self.sitdown&#x3D;1\n        else:\n            print(&quot;i am stand up&quot;)\n            self.sitdown&#x3D;0\na_dog&#x3D;Dog(&quot;abc&quot;,&quot;hound&quot;,3,*[1,2,3])\na_dog.print_arg()\npu&#x3D;puppy(&quot;abc&quot;,&quot;hound&quot;,3,0)\npu.sit()\npu.sit()\na_cat&#x3D;cat(&quot;abc&quot;,&quot;hound&quot;,3,*[1,2,3])\na_cat.play()\n\ncat 和puppy就是dog的子类\n在python中都有子类自动继承超类的方法，继承可以是直接的也可以是间接的，在这里puppy直接继承了cat类的所有方法，还继承了祖父类dog的所有属性\n子类继承了父类的所有方法，其中包括__init__ ，因此不是在所有时候都要重新编写__init__方法\n但也可以像上面puppy类这么写\n类变量和类方法类变量是由同一个类的所有成员共享的变量\neg1:\nclass Dog:\n    num_dogs&#x3D;0;\n    def __init__(self,name,breed,age):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\n        Dog.num_dogs+&#x3D;1\na_dog&#x3D;Dog(&quot;first_dog&quot;,&#39;ww&#39;,3)\nprint(&quot;dog_num: &quot;,Dog.num_dogs)\nanother_dog&#x3D;Dog(&quot;second_dog&quot;,&quot;ee&quot;,3)\nprint(&quot;Now_dog_num :&quot;,Dog.num_dogs)\n\n输出\ndog_num:  1\nNow_dog_num : 2\n\n实例变量在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的\nclass Address:\n    detail &#x3D; &quot;guangzhou&quot;\n    post_code &#x3D; &quot;510660&quot;\n    def info(self):\n        #尝试直接访问类变量\n        #print(detail) #报错\n\n        #通过类类访问类变量\n        print(Address.detail)\n        print(Address.post_code)\n\n#通过类来访问Address 类的类变量\nprint(Address.detail)\naddr &#x3D; Address()\naddr.info()\n#修改Address类的类变量\nAddress.detail &#x3D; &quot;fushan&quot;\n\nAddress.post_code &#x3D; &quot;460110&quot;\naddr.info()\n\n","slug":"Python类","date":"2022-10-27T13:17:47.000Z","categories_index":"","tags_index":"","author_index":"Shockley"},{"id":"61e647d1d27f6d8af1fd2619625e8201","title":"数组学习","content":"创建一维vectorvector&lt;int&gt; nums;&#x2F;&#x2F;不指定长度\nvector&lt;int&gt; nums(n); &#x2F;&#x2F; 指定长度为n \n\n添加元素nums.push_back(1);&#x2F;&#x2F;直接从数组末端添加\nnums[i] &#x3D; 1;&#x2F;&#x2F;直接赋值给第i个位置\n\n删除元素nums.resize(nums.size-i); &#x2F;&#x2F;直接将数组长度减小，某种方式上删掉了后面i个\nnums.pop_back();&#x2F;&#x2F;删掉最后一个元素\n\n遍历数组for(int i &#x3D; 0; i &lt; nums.size(); i++)&#123;\n    cout&lt;&lt;nums[i]&lt;&lt;endl;\n&#125;\n\n创建二维动态数组vector&lt;vector &lt;int&gt; &gt; nums(m ,vector&lt;int&gt;(n));    &#x2F;&#x2F;m*n的二维vector\n\n","slug":"数组学习","date":"2022-10-27T13:17:47.000Z","categories_index":"","tags_index":"","author_index":"Shockley"},{"id":"bf4eea2954747cade91d710bb8265d76","title":"结构体 共用体","content":"typedef 用于创建已定义的数据类型的别名\n共用体 与结构体类似，但是其中的成员公用一个储存空间\n位运算符 用于处理整数中的数位\n位域 结构体的整形或无符号型成员变量，实现数据的压缩存储\n枚举 用标识符表示的一组整形变量\n结构体（aggregate）结构体可以包含不同数据类型的变量，将指针与结构体联合使用，可以实现更复杂的数据结构，如：链表，队列，堆栈和树\nfor example\nstruct employee&#123;\n\tchar firstname[20];\n\tchar lastname[20];\n\tunsigned int age;\n\tchar gender;\n\tdouble hourlySaraly;\n&#125;;\n\n结构体的定义关键字 struct\n结构体的自引用结构体不能包含他的自身类型，但是指向同一个结构体的指针却可以出现在结构体的定义中\n称为自引用结构体，可构成链式结构\nstruct employee2&#123;\n\tchar firstname[20];\n\tchar lastname[20];\n\tunsigned int age;\n\tchar gender;\n\tdouble hourlySaraly;\n&#x2F;&#x2F;\tstruct employee2 teamleader; error\n\tstruct employee2 *teamleader; &#x2F;&#x2F;pointer\n&#125;;\n\n定义结构体的类型变量结构体的定义并不占用内存中的任何空间，它只是创建了一种新的可以用来定义变量的数据类型。\n下面是定义结构体变量的两种方式\nstruct card&#123;\n\tchar *face;\n\tchar *suit;\n&#125;;\nstruct card aCard ,deck[52],*cardPtr;\n\nstruct card&#123;\n\tchar *face;\n\tchar *suit;\n&#125;aCard ,deck[52],*cardPtr;\n\n执行完上面语句后，系统才为一个类型为struct card 的变量申请aCard、数组deck中的52个struct card和一个未初始化的指向struct card 类型的指针申请空间\n结构体标记名结构体标记名可以省略，但是省略时，结构体类型变量的声明就只能和结构体定义同时进行\n结构体初始化与数组一样，可以采用初始值列表来初始化结构体\nStructures can be initialized using initializer lists as with arrays. To initialize a structure, follow the variable name in the definition with an equals sign and a brace-enclosed, comma-separated list of initializers. For example, the declaration.\nstruct card aCard &#x3D; &#123; &quot;Three&quot;, &quot;Hearts&quot; &#125;;\n\n用.和 -&gt;访问结构体成员有两种运算符来访问结构体的成员：\n结构体成员运算符  structure member operator   ( . )\n结构体指针运算符 structure pointer operator -&gt;\n例如：\nprintf(&quot;%s&quot;, aCard.suit); &#x2F;&#x2F; displays Hearts\n\n假设cardPtr是struct card类型的指针并且指向acard\n则有：\nprintf(&quot;%s&quot;, cardPtr-&gt;suit); &#x2F;&#x2F; displays Hearts\n\nattention :The expression cardPtr-&gt;suit is equivalent to **(cardPtr).suit*\naCard.face&#x3D;&quot;ACE&quot;;\naCard.suit&#x3D;&quot;Spades&quot;;\ncardPtr&#x3D;&amp;aCard;\nprintf(&quot;%s%s%s&quot;,aCard.face,cardPtr-&gt;face,(*cardPtr).face);\n\n在函数中使用结构体\n传递结构体的个别成员\nWhen structures or individual structure members are passed to a function, they’re passed by value. Therefore, the members of a caller’s structure cannot be modified by the called function\n\n传递整个结构体\n\n传递指向结构体的指针\n\n\ntypedef 的使用typedef struct card Card;\n\nCard can now be used to declare variables of type struct card. The declaration\nCard deck[52];\ndeclares an array of 52 Card structures.\n\n\n\n\n\n\n\n\n\nCreating a new name with typedef does not create a new type;typedef simply creates a new type name, which may be used as an alias for an existing type name.\n位运算符\n","slug":"结构体 共用体 位操作和枚举类型","date":"2022-10-27T13:17:47.000Z","categories_index":"","tags_index":"","author_index":"Shockley"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\n编译hexo cl &amp;&amp; hexo g\n\nuploadhexo d\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-10-27T09:56:39.080Z","categories_index":"","tags_index":"","author_index":"Shockley"}]