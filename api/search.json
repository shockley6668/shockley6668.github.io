[{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"_ _init _ _创建classclass Dog:\n    def __init__(self,name,breed,age):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\na_dog&#x3D;Dog(&quot;abc&quot;,&quot;hound&quot;,3)\nprint(a_dog.age,a_dog.breed,a_dog.name)\n\n在类中定义函数class Dog:\n    def __init__(self,name,breed,age):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\n    def age_promote(self):\n        self.age+&#x3D;1\na_dog&#x3D;Dog(&quot;abc&quot;,&quot;hound&quot;,3)\nprint(a_dog.age,a_dog.breed,a_dog.name)\na_dog.age_promote()\nprint(a_dog.age)\n\n_ _str _ _def __str__(self):\n    &quot;&quot;&quot;返回一个对象的描述信息&quot;&quot;&quot;\n    # print(num)\n    return &quot;名字是:%s , 年龄是:%d&quot; % (self.name, self.age)\n\n变长参数列表语法\ndef function_name(fixed_arg,*args):\n    statements\n\narg可以是元组或列表\n*的意思是变长参数列表，即参数可能不确定\neg1：\nclass Dog:\n    def __init__(self,name,breed,age,*arg):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\n        self.list&#x3D;arg\n    def age_promote(self):\n        self.age+&#x3D;1\n    def print_arg(self):\n        for i in self.list:\n            print(i)\na_dog&#x3D;Dog(&quot;abc&quot;,&quot;hound&quot;,3,1,2,3)\na_dog.print_arg()\n\n输出1 2 3\neg2：\nclass Dog:\n    def __init__(self,name,breed,age,*arg):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\n        self.list&#x3D;arg\n    def age_promote(self):\n        self.age+&#x3D;1\n    def print_arg(self):\n        for i in self.list:\n            print(i)\na_dog&#x3D;Dog(&quot;abc&quot;,&quot;hound&quot;,3,[1,2,3])\na_dog.print_arg()\n\n输出[1,2,3]\neg3：\nclass Dog:\n    def __init__(self,name,breed,age,*arg):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\n        self.list&#x3D;arg\n    def age_promote(self):\n        self.age+&#x3D;1\n    def print_arg(self):\n        for i in self.list:\n            print(i)\na_dog&#x3D;Dog(&quot;abc&quot;,&quot;hound&quot;,3,*[1,2,3])\na_dog.print_arg()\n\n输出1 2 3（同eg1）\n继承一个类继承另一个类时，继承者是子类，被继承者是父类\nclass class_name(base_class):\n    class_definition\n\neg1:\nclass Dog:\n    def __init__(self,name,breed,age,*arg):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\n        self.list&#x3D;arg\n    def age_promote(self):\n        self.age+&#x3D;1\n    def print_arg(self):\n        for i in self.list:\n            print(i)\nclass cat(Dog):\n    def play(self):\n        s&#x3D;&#39;&#39;\n        while not s or s[0] in &#39;Nn&#39;:\n            print(self.name,&#39;fetches the balls!&#39;)\n            s&#x3D;input(&#39;wanna play again？(Y&#x2F;N)&#39;)\nclass puppy(cat):\n    def __init__(self,name,breed,age,sitdown):\n        cat.__init__(self,name,breed,age)\n        self.sitdown&#x3D;0\n    def sit(self):\n        if (self.sitdown&#x3D;&#x3D;0):\n            print(&quot;I am sitting down!&quot;)\n            self.sitdown&#x3D;1\n        else:\n            print(&quot;i am stand up&quot;)\n            self.sitdown&#x3D;0\na_dog&#x3D;Dog(&quot;abc&quot;,&quot;hound&quot;,3,*[1,2,3])\na_dog.print_arg()\npu&#x3D;puppy(&quot;abc&quot;,&quot;hound&quot;,3,0)\npu.sit()\npu.sit()\na_cat&#x3D;cat(&quot;abc&quot;,&quot;hound&quot;,3,*[1,2,3])\na_cat.play()\n\ncat 和puppy就是dog的子类\n在python中都有子类自动继承超类的方法，继承可以是直接的也可以是间接的，在这里puppy直接继承了cat类的所有方法，还继承了祖父类dog的所有属性\n子类继承了父类的所有方法，其中包括__init__ ，因此不是在所有时候都要重新编写__init__方法\n但也可以像上面puppy类这么写\n类变量和类方法类变量是由同一个类的所有成员共享的变量\neg1:\nclass Dog:\n    num_dogs&#x3D;0;\n    def __init__(self,name,breed,age):\n        self.name&#x3D;name\n        self.breed&#x3D;breed\n        self.age&#x3D;age\n        Dog.num_dogs+&#x3D;1\na_dog&#x3D;Dog(&quot;first_dog&quot;,&#39;ww&#39;,3)\nprint(&quot;dog_num: &quot;,Dog.num_dogs)\nanother_dog&#x3D;Dog(&quot;second_dog&quot;,&quot;ee&quot;,3)\nprint(&quot;Now_dog_num :&quot;,Dog.num_dogs)\n\n输出\ndog_num:  1\nNow_dog_num : 2\n\n实例变量在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的\nclass Address:\n    detail &#x3D; &quot;guangzhou&quot;\n    post_code &#x3D; &quot;510660&quot;\n    def info(self):\n        #尝试直接访问类变量\n        #print(detail) #报错\n\n        #通过类类访问类变量\n        print(Address.detail)\n        print(Address.post_code)\n\n#通过类来访问Address 类的类变量\nprint(Address.detail)\naddr &#x3D; Address()\naddr.info()\n#修改Address类的类变量\nAddress.detail &#x3D; &quot;fushan&quot;\n\nAddress.post_code &#x3D; &quot;460110&quot;\naddr.info()\n\n","slug":"Python类","date":"2022-10-27T12:49:43.187Z","categories_index":"","tags_index":"","author_index":"Shockley"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"创建一维vectorvector&lt;int&gt; nums;&#x2F;&#x2F;不指定长度\nvector&lt;int&gt; nums(n); &#x2F;&#x2F; 指定长度为n \n\n添加元素nums.push_back(1);&#x2F;&#x2F;直接从数组末端添加\nnums[i] &#x3D; 1;&#x2F;&#x2F;直接赋值给第i个位置\n\n删除元素nums.resize(nums.size-i); &#x2F;&#x2F;直接将数组长度减小，某种方式上删掉了后面i个\nnums.pop_back();&#x2F;&#x2F;删掉最后一个元素\n\n遍历数组for(int i &#x3D; 0; i &lt; nums.size(); i++)&#123;\n    cout&lt;&lt;nums[i]&lt;&lt;endl;\n&#125;\n\n创建二维动态数组vector&lt;vector &lt;int&gt; &gt; nums(m ,vector&lt;int&gt;(n));    &#x2F;&#x2F;m*n的二维vector\n\n","slug":"数组学习","date":"2022-10-27T12:49:40.081Z","categories_index":"","tags_index":"","author_index":"Shockley"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"结构体 共用体 位操作和枚举类型typedef 用于创建已定义的数据类型的别名\n共用体 与结构体类似，但是其中的成员公用一个储存空间\n位运算符 用于处理整数中的数位\n位域 结构体的整形或无符号型成员变量，实现数据的压缩存储\n枚举 用标识符表示的一组整形变量\n结构体（aggregate）结构体可以包含不同数据类型的变量，将指针与结构体联合使用，可以实现更复杂的数据结构，如：链表，队列，堆栈和树\nfor example\nstruct employee&#123;\n\tchar firstname[20];\n\tchar lastname[20];\n\tunsigned int age;\n\tchar gender;\n\tdouble hourlySaraly;\n&#125;;\n\n结构体的定义关键字 struct\n结构体的自引用结构体不能包含他的自身类型，但是指向同一个结构体的指针却可以出现在结构体的定义中\n称为自引用结构体，可构成链式结构\nstruct employee2&#123;\n\tchar firstname[20];\n\tchar lastname[20];\n\tunsigned int age;\n\tchar gender;\n\tdouble hourlySaraly;\n&#x2F;&#x2F;\tstruct employee2 teamleader; error\n\tstruct employee2 *teamleader; &#x2F;&#x2F;pointer\n&#125;;\n\n定义结构体的类型变量结构体的定义并不占用内存中的任何空间，它只是创建了一种新的可以用来定义变量的数据类型。\n下面是定义结构体变量的两种方式\nstruct card&#123;\n\tchar *face;\n\tchar *suit;\n&#125;;\nstruct card aCard ,deck[52],*cardPtr;\n\nstruct card&#123;\n\tchar *face;\n\tchar *suit;\n&#125;aCard ,deck[52],*cardPtr;\n\n执行完上面语句后，系统才为一个类型为struct card 的变量申请aCard、数组deck中的52个struct card和一个未初始化的指向struct card 类型的指针申请空间\n结构体标记名结构体标记名可以省略，但是省略时，结构体类型变量的声明就只能和结构体定义同时进行\n结构体初始化与数组一样，可以采用初始值列表来初始化结构体\nStructures can be initialized using initializer lists as with arrays. To initialize a structure, follow the variable name in the definition with an equals sign and a brace-enclosed, comma-separated list of initializers. For example, the declaration.\nstruct card aCard &#x3D; &#123; &quot;Three&quot;, &quot;Hearts&quot; &#125;;\n\n用.和 -&gt;访问结构体成员有两种运算符来访问结构体的成员：\n结构体成员运算符  structure member operator   ( . )\n结构体指针运算符 structure pointer operator -&gt;\n例如：\nprintf(&quot;%s&quot;, aCard.suit); &#x2F;&#x2F; displays Hearts\n\n假设cardPtr是struct card类型的指针并且指向acard\n则有：\nprintf(&quot;%s&quot;, cardPtr-&gt;suit); &#x2F;&#x2F; displays Hearts\n\nattention :The expression cardPtr-&gt;suit is equivalent to **(cardPtr).suit*\naCard.face&#x3D;&quot;ACE&quot;;\naCard.suit&#x3D;&quot;Spades&quot;;\ncardPtr&#x3D;&amp;aCard;\nprintf(&quot;%s%s%s&quot;,aCard.face,cardPtr-&gt;face,(*cardPtr).face);\n\n在函数中使用结构体\n传递结构体的个别成员\nWhen structures or individual structure members are passed to a function, they’re passed by value. Therefore, the members of a caller’s structure cannot be modified by the called function\n\n传递整个结构体\n\n传递指向结构体的指针\n\n\ntypedef 的使用typedef struct card Card;\n\nCard can now be used to declare variables of type struct card. The declaration\nCard deck[52];\ndeclares an array of 52 Card structures.\n\n\n\n\n\n\n\n\n\nCreating a new name with typedef does not create a new type;typedef simply creates a new type name, which may be used as an alias for an existing type name.\n位运算符\n","slug":"结构体 共用体 位操作和枚举类型","date":"2022-10-27T12:49:04.508Z","categories_index":"","tags_index":"","author_index":"Shockley"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-10-27T09:56:39.080Z","categories_index":"","tags_index":"","author_index":"Shockley"}]